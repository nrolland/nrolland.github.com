<?Xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>xQuant - On Understanding Types, Data Abstraction, and Polymorphism</title>
        <link rel="stylesheet" type="text/css" href="../../css/lhs.css" />
        <link rel="stylesheet" type="text/css" href="../../css/styling.css" />
        <link rel="alternate" type="application/rss+xml" title="xQuant.net Atom feed" href="http://xquant.net/atom.xml" /> 
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <div id="main-div" class="row;column;padding:0px">
            <div class="top-bar">
              <div class="top-bar-left">
                <ul class="menu" style="margin:25px" data-dropdown-menu>
                    <li class="menu-text"><h3><a href="../../">Home</a></li></h3>
               </ul>
              </div>
            </div>
            <div id="content" class="row column main" style="min-height:500px">
             
              <h1>On Understanding Types, Data Abstraction, and Polymorphism</h1>
             <div class="info">
    Posted on September 18, 2017
    
</div>
<div class="info">
    
</div>


<h3 id="section"></h3>

<p>We explore Luca Cardelli and Peter Wegner seminal <a href="http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf">paper</a> which illustrates how types and abstraction <strong>influences design of practical programming languages</strong></p>
<p>TODO : - regarder pretnar languages - faire un typed lambda calculus - exemple de stack, ou complexe avec unfold abstract datatype - faire un evaluateur avec CPS value level et type level comme fun with type function - dans servant, permet de varier le type, mais une seule valeur - dans ce papier, fct avec retour fct de type permet de varier le type avec la valeur, qui varie aussi - fun w phantom, reflection on types</p>
<h1 id="plan">Plan</h1>
<p>Quelques reflexions abstraites, exemple pratique. Repenser les features d’un language comme realisation d’un concept.</p>
<h1 id="universes">Universes</h1>
<p>An untyped “universe” is some fixed set of values.</p>
<ul>
<li>Bit strings in computer memory</li>
<li>S-expressions in pure Lisp</li>
<li>λ-expressions in the λ-calculus</li>
<li>Sets in set theory</li>
</ul>
<p>Types arise informally in any domain to categorize objects. The classification of objects in terms of the purposes for which they are used eventually results in a more or less well-defined type system. Types arise naturally, even starting from untyped universes</p>
<ul>
<li>The set of apples VS the set of motorcycles.</li>
<li>characters and operations, both represented as bit strings</li>
<li>In Lisp, some S-expressions are called lists while others form legal programs.</li>
<li>In λ-calculus some functions are chosen to represent boolean values, others to represent integers.</li>
<li>In set theory some sets are chosen to denote ordered pairs, and some sets of ordered pairs are then called functions</li>
</ul>
<p>A typed universe is a type whose elements are types.</p>
<h1 id="static-dynamic">Static, dynamic</h1>
<ul>
<li>Static typing : types of expressions can be determined by static program analysis</li>
<li>Weaker requirement : expressions are guaranteed to be type-consistent although the type itself may be statically unknown; this can be generally done by introducing some run-time type checking.</li>
</ul>
<h1 id="polymorphism">Polymorphism</h1>
<ul>
<li>monomorphic languages : functions and procedures have a unique type</li>
<li><p>polymorphic languages : some values and variables may have more than one type</p></li>
<li><p>Parametric polymorphism : works for a range of type uniformly, same behaviour for all types</p></li>
</ul>
<p>e.g : <code>length :: forall a. [a] -&gt; Int</code> - ad-hoc polymorphism : works for a range of type, with different behaviour for each type for which it works</p>
<p>(discussion on coercions and overloading skipped)</p>
<h1 id="type-expression-sublanguage">Type expression sublanguage</h1>
<pre><code>Type ::= BasicType | ConstructedType
BasicType ::= Int | Bool | ...
ConstructedType ::= Array(Type) | Type → Type | ...</code></pre>
<p>in code</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TyInt</span>
<span class="kw">data</span> <span class="dt">TyBool</span>
<span class="kw">data</span> <span class="dt">TyFun</span> a b

<span class="co">-- :kind TyBool</span>
<span class="co">-- TyBool :: *</span>
<span class="co">-- :k TyFun</span>
<span class="co">-- TyFun :: * -&gt; * -&gt; *</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- TyInt is a type of kind Typ, as Int is a type of kind Type</span>
<span class="kw">data</span> <span class="dt">Typ</span> <span class="fu">=</span> <span class="dt">TyInt</span> <span class="fu">|</span> <span class="dt">TyBool</span> <span class="fu">|</span> <span class="dt">TyFun</span> <span class="dt">Typ</span> <span class="dt">Typ</span> <span class="co">-- ...</span></code></pre></div>
<p>with quantification</p>
<pre><code>Type ::= ... | QuantifiedType
QuantifiedType ::=
∀A. Type | Universal Quantification
∃A. Type | Existential Quantification
∀A⊆Type. Type | ∃A⊆Type. Type</code></pre>
<p>in code</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Typ</span> <span class="fu">=</span> <span class="dt">BasicTyp</span> <span class="fu">|</span> <span class="dt">ConstructedType</span> <span class="fu">|</span> <span class="dt">QuantifiedTyp</span>

<span class="kw">data</span> <span class="dt">BasicTyp</span> <span class="fu">=</span> <span class="dt">TyInt</span> <span class="fu">|</span> <span class="dt">TyBool</span>

<span class="kw">data</span> <span class="dt">ConstructedTyp</span> <span class="fu">=</span> <span class="dt">TyFun</span> <span class="dt">Typ</span> <span class="dt">Typ</span> <span class="co">-- ...</span>

<span class="kw">data</span> <span class="dt">QuantifiedTyp</span> <span class="kw">where</span>
   <span class="dt">Forall</span><span class="ot"> ::</span> (forall t<span class="fu">.</span> t <span class="ot">-&gt;</span> <span class="dt">Typ</span>) <span class="ot">-&gt;</span> <span class="dt">QuantifiedTyp</span>
   <span class="dt">Exists</span><span class="ot"> ::</span> forall a<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">Typ</span>) <span class="ot">-&gt;</span> <span class="dt">QuantifiedTyp</span></code></pre></div>
<h1 id="constraining-discourse">Constraining discourse</h1>
<p>The more we restrict what is allowed to be said, the more guidance the user of our system will have to build useful and bug free program. A type system’s goal is :</p>
<ul>
<li>to inform a program is illegal by rejecting it</li>
<li>to accept as many good program as possible</li>
</ul>
<h1 id="untyped-lambda-calculus">Untyped lambda calculus</h1>
<p>A minimal language to talk about function is lambda calculus. Its expressions have the following syntax</p>
<ul>
<li>e ::= x – a variable is a λ-expression</li>
<li>e ::= fun(x)e – functional abstraction of e</li>
<li>e ::= e(e) – operator e applied to operand e</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">Text</span>

<span class="kw">data</span> <span class="dt">Exp</span> <span class="kw">where</span>
    <span class="dt">Var</span><span class="ot"> ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
    <span class="dt">Lam</span><span class="ot"> ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
<span class="ot">    (:@:) ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>  <span class="ot">-&gt;</span> <span class="dt">Exp</span>
    <span class="dt">Lit</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Exp</span>

<span class="co">-- ex : identity function</span>
id<span class="ot"> ::</span> <span class="dt">Exp</span>
id <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> <span class="fu">$</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>

<span class="co">-- ex : flip x y = y x</span>
<span class="ot">flip' ::</span> <span class="dt">Exp</span>
flip' <span class="fu">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> <span class="fu">$</span> <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> <span class="fu">$</span> <span class="dt">Var</span> <span class="st">&quot;f&quot;</span> <span class="fu">:@:</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>

<span class="co">-- ex : 'bad' expression undetected</span>
<span class="ot">bad ::</span> <span class="dt">Exp</span>
bad <span class="fu">=</span> flip' <span class="fu">:@:</span> <span class="dt">Lit</span> <span class="dv">4</span> <span class="fu">:@:</span> <span class="dt">Lit</span> <span class="dv">4</span></code></pre></div>

<h1 id="typed-lambda-calculus">Typed lambda calculus</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">Text</span>

<span class="co">-- TyInt is a type of kind Typ, as Int is a type of kind Type</span>
<span class="kw">data</span> <span class="dt">Typ</span> <span class="fu">=</span> <span class="dt">TyInt</span> <span class="fu">|</span> <span class="dt">TyBool</span> <span class="fu">|</span> <span class="dt">TyFun</span> <span class="dt">Typ</span> <span class="dt">Typ</span> <span class="co">-- ...</span>


<span class="co">-- &quot;making illegal state unrepresentable&quot; with types</span>
<span class="kw">data</span> <span class="dt">Exp</span><span class="ot"> ::</span> <span class="dt">Typ</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
    <span class="dt">VarInt</span><span class="ot">   ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="dt">TyInt</span>
    <span class="dt">VarBool</span><span class="ot">  ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="dt">TyBool</span>
    <span class="dt">Lam</span><span class="ot">      ::</span> (<span class="dt">Exp</span> a <span class="ot">-&gt;</span> <span class="dt">Exp</span> b) <span class="ot">-&gt;</span> <span class="dt">Exp</span> (<span class="dt">TyFun</span> a b)
<span class="ot">    (:@:)    ::</span> <span class="dt">Exp</span> (<span class="dt">TyFun</span> a b) <span class="ot">-&gt;</span> <span class="dt">Exp</span> a <span class="ot">-&gt;</span> <span class="dt">Exp</span> b
    <span class="dt">LitInt</span><span class="ot">   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="dt">TyInt</span>

<span class="co">-- ex : identity function</span>
<span class="ot">idInt ::</span> <span class="dt">Exp</span> (<span class="dt">TyFun</span> <span class="dt">TyInt</span> <span class="dt">TyInt</span>)
idInt <span class="fu">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> x)   <span class="co">-- &quot;x&quot; provided for us by host language</span>

<span class="ot">idText ::</span> <span class="dt">Exp</span> (<span class="dt">TyFun</span> <span class="dt">TyBool</span> <span class="dt">TyBool</span>)
idText <span class="fu">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> x)  <span class="co">-- &quot;x&quot; provided for us by host language</span>

<span class="co">-- ex : flip x y = y x</span>
<span class="ot">flip' ::</span> <span class="dt">Exp</span> (<span class="dt">TyFun</span> <span class="dt">TyInt</span> (<span class="dt">TyFun</span> (<span class="dt">TyFun</span> <span class="dt">TyInt</span> <span class="dt">TyBool</span>) <span class="dt">TyBool</span>))  <span class="co">-- rich type vs previous &quot;Exp&quot;</span>
flip' <span class="fu">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> <span class="dt">Lam</span> (\f <span class="ot">-&gt;</span> f <span class="fu">:@:</span> x))


<span class="co">-- ex : 'bad' expression   -- error provided by the host language</span>
<span class="co">-- bad = flip' :@: (Lit 4) :@: (Lit 4)</span>
    <span class="co">--   Couldn't match type ‘'TyInt’ with ‘'TyFun 'TyInt 'MyText’</span>
    <span class="co">--   Expected type: Exp ('TyFun 'TyInt 'MyText)</span>
    <span class="co">--     Actual type: Exp 'TyInt</span></code></pre></div>
<p>nb : we restrict ourselves to not using typeclasses for better portability. There are many different ways to embed a language into another but typeclasses allow a fine control and are an excellent level of abstraction. cf <a href="http://okmij.org/ftp/tagless-final/course/lecture.pdf">Oleg’s Typed Tagless Final Interpreters</a>. In particular it allows to separate the abstract <em>language</em> from the chosen <em>representation</em> and to not directly operate on encodings.</p>
<h1 id="types-as-set-of-values">Types as Set of values</h1>
<p>cf paper</p>
<h1 id="universal-quantification">Universal quantification</h1>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">Text</span>

<span class="co">-- stealing even more from the host language</span>
<span class="kw">data</span> <span class="dt">Exp</span> a <span class="kw">where</span>
    <span class="co">-- Var :: MyTyp a =&gt; Name -&gt; Exp a -- to restrain universe</span>
    <span class="dt">Var</span><span class="ot"> ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> a
    <span class="dt">Lam</span><span class="ot"> ::</span> (<span class="dt">Exp</span> a <span class="ot">-&gt;</span> <span class="dt">Exp</span> b) <span class="ot">-&gt;</span> <span class="dt">Exp</span> (a <span class="ot">-&gt;</span> b)   <span class="co">-- HOAS</span>
<span class="ot">    (:@:) ::</span> <span class="dt">Exp</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Exp</span> a  <span class="ot">-&gt;</span> <span class="dt">Exp</span> b
    <span class="dt">Lit</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Exp</span> a

<span class="co">-- ex : identity function</span>
id<span class="ot"> ::</span> forall a<span class="fu">.</span> <span class="dt">Exp</span> (a <span class="ot">-&gt;</span> a) <span class="co">-- ONE function FOR ALL types</span>
id <span class="fu">=</span> <span class="dt">Lam</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> x

<span class="co">-- ex : flip x y = y x</span>
<span class="ot">flip' ::</span> <span class="dt">Exp</span> (a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b)  <span class="co">-- rich type vs Exp</span>
flip' <span class="fu">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> <span class="dt">Lam</span> (\f <span class="ot">-&gt;</span> f <span class="fu">:@:</span> x))

<span class="co">-- ex : 'bad' expression   -- error provided by the host language</span>
<span class="co">-- bad = flip' :@: (Lit 4) :@: (Lit 4)</span></code></pre></div>
<p>Providing a universal quantification function allow more liberty to the caller. Requiring a universally quantified function means demanding more liberty from the provider.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a
f x <span class="fu">=</span> undefined <span class="co">-- how many functions ?</span></code></pre></div>
<p>A difference in type <strong>only</strong> is significant and conveys meaning.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">twice1 ::</span> forall t<span class="fu">.</span> (forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t
twice1 f x <span class="fu">=</span> f (f x)

<span class="ot">twice2 ::</span> forall t<span class="fu">.</span> (t <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t
twice2 f x <span class="fu">=</span> f (f x)

<span class="co">-- ok</span>
_ <span class="fu">=</span> twice1 (\x <span class="ot">-&gt;</span> x) <span class="dv">3</span>
_ <span class="fu">=</span> twice2 (\x <span class="ot">-&gt;</span> x) <span class="dv">3</span>


<span class="co">-- legal</span>
_ <span class="fu">=</span> twice2 (\x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span>) <span class="dv">3</span>

<span class="co">-- illegal</span>
_ <span class="fu">=</span> twice1 (\x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span>) <span class="dv">3</span></code></pre></div>
<h1 id="existential-quantification-information-hiding">Existential quantification, information hiding</h1>
<p>We can create value with an <em>existential</em> type which hide a particular type parameter</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Computation</span> r <span class="kw">where</span>
  <span class="dt">Computation</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Computation</span> r

<span class="kw">data</span> <span class="dt">C</span> r <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">C</span> {const<span class="ot"> ::</span> a,<span class="ot"> op ::</span> a <span class="ot">-&gt;</span> r}

<span class="ot">x ::</span> <span class="dt">Computation</span> <span class="dt">Int</span>
x <span class="fu">=</span> <span class="dt">Computation</span> <span class="dv">3</span>  ((<span class="fu">+</span>) <span class="dv">1</span>)

<span class="ot">y ::</span> <span class="dt">Computation</span> <span class="dt">Int</span>
y <span class="fu">=</span> <span class="dt">Computation</span> [<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">1</span>] length</code></pre></div>
<p>This restrict what we can legitimately do</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">use ::</span> <span class="dt">Computation</span> r <span class="ot">-&gt;</span> r
use (<span class="dt">Computation</span> (<span class="ot">param ::</span> a) (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> r)) <span class="fu">=</span> f param <span class="co">-- exists a, pas de length etc..</span></code></pre></div>
<p>The module systems can be used to create “abstract data type”, hiding a particular representation. There are 2 languages in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Client</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Protolude</span>

<span class="kw">import </span><span class="dt">Point</span> <span class="co">-- open record of functions</span>

pt <span class="fu">=</span> mkPoint (<span class="dv">0</span>,<span class="dv">0</span>) <span class="co">-- uses it</span></code></pre></div>
<p>the implementation hide wether we use cartesian, polar coordinate, etc..</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Point</span> (<span class="dt">Point</span>, mkPoint, px, py <span class="co">-- export list</span>
            ) <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Protolude</span>

<span class="kw">newtype</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span> (<span class="dt">Float</span>,<span class="dt">Float</span>) <span class="co">-- data constructor hidden outside</span>

<span class="ot">mkPoint ::</span> (<span class="dt">Float</span>, <span class="dt">Float</span>) <span class="ot">-&gt;</span> <span class="dt">Point</span>
mkPoint t <span class="fu">=</span> <span class="dt">Point</span> t

<span class="ot">px ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
px p <span class="fu">=</span> <span class="kw">let</span> (<span class="dt">Point</span> (x,_)) <span class="fu">=</span> p <span class="kw">in</span> x

<span class="ot">py ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
py p <span class="fu">=</span> <span class="kw">let</span> (<span class="dt">Point</span> (_,y)) <span class="fu">=</span> p <span class="kw">in</span> y</code></pre></div>


            </div>
        </div>

        <footer>
            <div class="footer"> </div>
        </footer>
        <!-- Third-party -->
        <script src="../../js/jquery.min.js" type="application/javascript"></script>
        <script src="../../js/what-input.min.js" type="application/javascript"></script>
        <script src="../../js/foundation.min.js" type="application/javascript"></script>
        <script>
         