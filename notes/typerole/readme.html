<?Xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>xQuant - Notes - typerole</title>
        <link rel="stylesheet" type="text/css" href="../../css/lhs.css" />
        <link rel="stylesheet" type="text/css" href="../../css/styling.css" />
        <link rel="alternate" type="application/rss+xml" title="xQuant.net Atom feed" href="http://xquant.net/atom.xml" /> 
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <div id="main-div" class="row;column;padding:0px">
            <div class="top-bar">
              <div class="top-bar-left">
                <ul class="menu" style="margin:25px" data-dropdown-menu>
                    <li class="menu-text"><h3><a href="../../">Home</a></li></h3>
               </ul>
              </div>
            </div>
            <div id="content" class="row column main" style="min-height:500px">
             
              <h1>Notes - typerole</h1>
             <div class="info">
    Posted on June  3, 2018
    
</div>
<div class="info">
    
</div>



<p>from <a href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf">Generative Type Abstraction and Type-level Computation - weirich vytiniotis spj zdancewic</a></p>
<h1 id="motivation-personelle">Motivation personelle</h1>
<p>Comment raffiner une theorie en gardant en interne le fait que deux operations doivent etre egales, et en forcant les clients a travailler sans cette egalite. Cette question revient frequemment : on remplace une egalite (qui est une idee platonicienne, existant de toute eternite) par un isomorphisme (qui est une fonction, qui a un nom, qui peut etre passse en argument).</p>
<p>On en voit une autre illustration dans les types de Haskell, ou attribuer des noms differents a des structures identiques force les clients a distinguer et a referencer explicitement des isos pour passer d’un type a un autre.</p>
<p>Nous regardons donc comment c’est traite dans le papier mentionne</p>
<h1 id="introduction">Introduction</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">newtype</span> <span class="dt">Age</span> <span class="fu">=</span> <span class="dt">MkAge</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">data</span> <span class="dt">K</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="dt">KAge</span><span class="ot"> ::</span> <span class="dt">K</span> <span class="dt">Age</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="dt">KInt</span><span class="ot"> ::</span> <span class="dt">K</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="ot">cvt ::</span> <span class="ot">∀</span> c<span class="fu">.</span> c <span class="dt">Int</span> <span class="ot">→</span> c <span class="dt">Age</span></a>
<a class="sourceLine" id="cb1-8" title="8">cvt x <span class="fu">=</span> <span class="fu">undefined</span> <span class="co">-- identite : an Age is an Int</span></a></code></pre></div>
<p>remarque interessante sur les modules dans ML, ou DANS un module, on Age et Int sont <em>vraiment</em> synonymes.</p>
<h2 id="trouble-in-paradise">trouble in paradise</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">kint ::</span> <span class="dt">K</span> <span class="dt">Age</span></a>
<a class="sourceLine" id="cb2-2" title="2">kint <span class="fu">=</span> cvt <span class="dt">KInt</span> <span class="co">-- the representation is the same</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">get ::</span> <span class="dt">K</span> <span class="dt">Age</span> <span class="ot">→</span> <span class="dt">Bool</span> <span class="co">-- only defined at K Age</span></a>
<a class="sourceLine" id="cb2-5" title="5">get <span class="dt">KAge</span> <span class="fu">=</span> <span class="dt">True</span>     <span class="co">-- so this pattern match is exhaustive</span></a></code></pre></div>
<p>yet this will fail :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">vf <span class="fu">=</span> get kint</a></code></pre></div>
<p>(flash news : le domaine d’une fonction fait partie de sa definition. fonction identite agit uniformement, mais l’identite en A n’est pas l’identite en B. si les noms ont de l’importance, ca ne passe pas sans preuve que A = B, preuve detenue uniquement <em>en interne</em> par la personne ayant cree le newtype.)</p>
<h2 id="more-trouble">more trouble</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">F</span><span class="ot"> a ::</span> <span class="fu">*</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Age</span> <span class="fu">=</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">Bool</span></a></code></pre></div>
<p>Permet de deduire :</p>
<ul>
<li>Bool ~ F Int</li>
<li>F Int ~ F Age</li>
<li>F Age ~ Char</li>
<li>=&gt; Bool ~ Char (!?)</li>
</ul>
<p>“What went wrong? Maybe it should be illegal for a type function to behave differently on two coercible types, such as Age and Int? But in fact Haskell programmers often use newtypes precisely so that they can give a different type-class instance (for comparison, say) for Age than for the underlying Int. Type functions are no different;”</p>
<p>On se sert des types synomymes pour introduire des NOMS. ces noms ne doivent pas etre identifies pour les CLIENTS de ces noms. Les type functions, type classes sont clients, il faut leur cacher l’equation en notre possession (Age = Int).</p>
<h2 id="yet-more-trouble">yet more trouble</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">data</span> <span class="dt">TF</span> a <span class="fu">=</span> <span class="dt">MkTF</span> (<span class="dt">F</span> a)</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">to ::</span> <span class="dt">Bool</span><span class="ot">→</span> <span class="dt">TF</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-2" title="2">to b <span class="fu">=</span> <span class="dt">MkTF</span> b</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">from ::</span> <span class="dt">TF</span> <span class="dt">Age</span><span class="ot">→</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb6-5" title="5">from (<span class="dt">MkTF</span> c) <span class="fu">=</span> c</a></code></pre></div>
<p>this will fail</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">vf2 <span class="fu">=</span> from <span class="fu">.</span> cvt <span class="fu">.</span> to</a></code></pre></div>
<p>cvt utilise une preuve qui doit rester privee. a l’exterieur, les differences de noms doivent creer des differences</p>
<p>“This problem is important .. because the same issues will arise in any type system that combines type-level dispatch and coercion lifting.”</p>
<p>Coercion lifting : if for two types φ and ψ we have φ ∼ ψ (for example, if they are the abstract and concrete types of a newtype declaration), then T φ ∼ T ψ for any type constructor T .</p>
<p>qui n’est valable que d’un point de vue INTERNE ou les noms n’ont pas d’importance</p>
<h1 id="fc2">FC2</h1>
<p>• On peut voir Age et Int comme deux noms differents =&gt; “we can view Age and IntCode as two different codes that both map to the type Int”</p>
<p>• “the important distinction between codes and types is that they have different definitions of equality. In the encoding above, the codes Age and IntCode are different codes, but their interpretations are equal types” differentes definition de l’egalite, surtout preuves privees VS preuves publique. JE peux decider de creer deux noms que moi seul peut identifier. TU es force de penser qu’ils sont distincts. ce qui se passe avec les types abstraits et les valeurs, se passe aussi pour les fonctions de types et le systeme logique.</p>
<p>• “Age and Int are distinct when viewed at role code but equal when viewed at role type. Code equality is used to reason about the meaning of type-indexed functions and is finer-grained than type equality, which is used to determine which type coercions are safe”</p>
<p>“role type” : role dieu de la phase compilation, qui ne voit que l’utilisation finale : c’est un Int ou c’est un Bool ? Les autres subtilites sont detruites. Je peux devenir un dieu local et forcer mes clients a faire une distinction que moi seul peut lever, mais je reste soumis a mon dieu (qui identifie les types).</p>
<p>on a une hierarchie de dieu, et une relation d’ordre.</p>
<h2 id="description-de-fc2">Description de FC2</h2>
<p>FC2 is ex- pressive enough to capture indexed type functions, newtype and newtype deriving,GADTs,existentialandnesteddatatypes, and much more.</p>
<p>First, FC2 provides polymorphic datatypes,</p>
<p>Second, FC2 includes first-class proofs of type equality that witness safe coercions introduced during compilation</p>
<h2 id="syntax-directed-typechecking">Syntax directed typechecking</h2>
<p>Programs in FC2 can abstract over coercions reflecting a particular type equal- ity (written Λc : φ1 ∼ φ2.e), pass a coercion as an argument to such a function (written e γ), and use a coercion to cast a term from one type to another (written e ◃ γ). These explicit coercions, written γ, make typechecking FC2 programs syntax-directed.</p>
<p><strong>The syntax of an FC2 term encodes its typing derivation</strong></p>
<p>Why is this important?</p>
<p>• The idea is that the compiler’s front end performs perhaps-complex type inference on the source program, and records the proofs generated by inference directly in the syntax of the FC2 intermediate language.</p>
<p>• The optimiser transforms FC2 terms, perhaps radically.</p>
<p>At any point one can check the consistency of the resulting FC2 program using a simple, fast, syntax- directed typechecker; this consistency check has proven to be an extremely powerful aid to getting the compiler right. It is just as easy to find the type of an arbitrary FC2 term, an ability that is used extensively inside GHC.</p>
<p>Ma syntaxe reflete parfaitement la construction des proprietes logiques dont je veux parler, et toute l’information pour retrouver/verifier un propriete est dans mon terme, avec toutes les etapes intermediaires</p>
<h2 id="fc2-types-and-kinds">FC2 types and kinds</h2>
<p>Types in FC2 are classified by pairs κ of the form η/R, where :</p>
<p>• the kind η ensures (as usual) that types are well-formed structurally</p>
<p>• the role R that determines the precision at which they can be analyzed.</p>
<p>Codes (which distinguish Age and Int) have role C, whereas types (which identify them) have role T.</p>
<p>Par exemple :</p>
<p>The distinction between codes and types allows us to give infor- mative kinds to type constructors:</p>
<p>• The Maybe type (Section 2.1) has kind ⋆/T → ⋆, indicating that Maybe treats its argument parametrically (les proprietes logiques de Maybe s’expriment via le dieu compilation, et s’imposent a tous)</p>
<p>• The types K, F, and TF (Section 2.2) all use type indexing and therefore have kind ⋆/C → ⋆. (les proprietes de logiques de )</p>
<p>These kinds in turn support the key insight of this paper: <strong>it is only safe to lift coercions through functions with parametric kinds</strong></p>
<p>So Maybe Age ∼ Maybe Int holds but TF Age ̸∼ TF Int.</p>
<p>Parce que Maybe se refere au dieu compilation qui s’impose aux autres dieux locaux, qui ne sont que des intercesseurs. Tandis que les TF sont des clients de Dieux non precises, potentiellement autres que celui de la compilation</p>

            </div>
        </div>

        <footer>
            <div class="footer"> </div>
        </footer>
        <!-- Third-party -->
        <script src="../../js/jquery.min.js" type="application/javascript"></script>
        <script src="../../js/what-input.min.js" type="application/javascript"></script>
        <script src="../../js/foundation.min.js" type="application/javascript"></script>
        <script>
         