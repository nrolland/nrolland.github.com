<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>xQuant</title>
    <link href="http://xquant.net/atom.xml" rel="self" />
    <link href="http://xquant.net" />
    <id>http://xquant.net/atom.xml</id>
    <author>
        <name>Nicolas Rolland</name>
        <email></email>
    </author>
    <updated>2017-10-26T00:00:00Z</updated>
    <entry>
    <title>2017-10-26-Weekly-links</title>
    <link href="http://xquant.net/weekly/2017-10-26-Weekly-links.html" />
    <id>http://xquant.net/weekly/2017-10-26-Weekly-links.html</id>
    <published>2017-10-26T00:00:00Z</published>
    <updated>2017-10-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2017-10-26</h1>
<!-- <aside>Posted on 2017-10-26</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://plzoo.andrej.com/" >The Programming Languages Zoo</a>
    </dt>
    <dd>The Programming Languages Zoo is a collection of miniature programming languages which demonstrates various concepts and techniques used in programming language design and implementation. It is a good starting point for those who would like to implement their own programming language, or just learn how it is done.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/psibi/dhall-mode" >psibi/dhall-mode</a>
    </dt>
    <dd>Emacs Major mode for working with Dhall configuration language</dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>2017-09-18-Weekly-links</title>
    <link href="http://xquant.net/weekly/2017-09-18-Weekly-links.html" />
    <id>http://xquant.net/weekly/2017-09-18-Weekly-links.html</id>
    <published>2017-09-18T00:00:00Z</published>
    <updated>2017-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2017-09-18</h1>
<!-- <aside>Posted on 2017-09-18</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://www.lamdu.org/" >Lamdu</a>
    </dt>
    <dd>This project aims to create a next-generation live programming environment that radically improves the programming experience</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/firehol/netdata" >firehol/netdata: Get control of your servers. Simple. Effective. Awesome! https://my-netdata.io/</a>
    </dt>
    <dd>netdata is a system for distributed real-time performance and health monitoring. It provides unparalleled insights, in real-time, of everything happening on the system it runs (including applications such as web and database servers), using modern interactive web dashboards.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://www.autodeskresearch.com/publications/samestats" >Same Stats, Different Graphs: Generating Datasets with Varied Appearance and Identical Statistics through Simulated Annealing | Autodesk Research</a>
    </dt>
    <dd></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://distill.pub/2017/momentum/" >Why Momentum Really Works</a>
    </dt>
    <dd>Really nice illustrated mathematics on the web</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/sweirich/pi-forall" >sweirich/pi-forall: A demo implementation of a simple dependently-typed language</a>
    </dt>
    <dd>Pi-Forall language<br><br>This language implementation is designed to accompany four lectures at OPLSS during Summer 2014. Notes for these lectures are included in the distribution:<br></dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>Design - part 2 - Putting types to work</title>
    <link href="http://xquant.net/notes/TypeRep/readme.html" />
    <id>http://xquant.net/notes/TypeRep/readme.html</id>
    <published>2017-04-12T00:00:00Z</published>
    <updated>2017-04-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on April 12, 2017
    
</div>
<div class="info">
    
</div>



<p>Where we venture into using types as drivers, not just as verifiers.</p>
<p>illustrating ideas from <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf">fun with phantom type</a> the commented code is from <a href="https://gist.github.com/linusyang/4057470cf96b88d13bd8">here</a></p>
<h1 id="warmup---interpreter">Warmup - Interpreter</h1>
<p>If we represent a language with untyped <code>Exp</code> data type, when consuming a represented program, we have to add type coercions to convince the type system : we check the value of type <code>Exp</code> received <em>really</em> contains the expected data inside, and we assert that to the compiler in some way to do something with it.</p>
<p>If we use GADT, some extra type information is packed with the data constructor/destructor. as we pattern math on the value, the type become more precise as the index gets fixed. we uncover type information as we uncover data information.</p>
<p>This makes evaluation straightforward :</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term1</span> a <span class="kw">where</span>
  <span class="dt">Zero</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Int</span>
  <span class="dt">Succ</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term1</span> <span class="dt">Int</span>
  <span class="dt">Pred</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term1</span> <span class="dt">Int</span>
  <span class="dt">IsZero</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Int</span>  <span class="ot">-&gt;</span>  <span class="dt">Term1</span> <span class="dt">Bool</span>
  <span class="dt">If</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Term1</span> a <span class="ot">-&gt;</span> <span class="dt">Term1</span> a <span class="ot">-&gt;</span> <span class="dt">Term1</span> a

<span class="ot">eval ::</span> forall a<span class="fu">.</span> <span class="dt">Term1</span> a <span class="ot">-&gt;</span> a
eval (<span class="dt">Zero</span> <span class="co">{- a is bound to Int from here-}</span>)  <span class="fu">=</span> <span class="dv">0</span> <span class="co">-- so 0 :: Int</span>
eval (<span class="dt">Succ</span> n<span class="co">{- a is bound to Int from here-}</span>) <span class="fu">=</span> eval n <span class="co">{-:: Int -}</span> <span class="fu">+</span> <span class="dv">1</span> <span class="co">-- type correct</span>
eval (<span class="dt">Pred</span> n)                                 <span class="fu">=</span> eval n <span class="fu">-</span> <span class="dv">1</span>
eval (<span class="dt">IsZero</span> n)                               <span class="fu">=</span> eval n <span class="fu">==</span> <span class="dv">0</span>
eval (<span class="dt">If</span> e1 e2 e3) <span class="fu">=</span> <span class="kw">if</span> eval e1 <span class="kw">then</span> eval e2 <span class="kw">else</span> eval e3</code></pre></div>
<p>There can not be a function <code>map :: (a -&gt; b) -&gt; Term1 a -&gt; Term1 b</code></p>
<p>The type index in term does not mean there is a value of that type in it to apply <code>a -&gt; b</code> to. It is called a “phantom type”, other name for an type index seen as a “pure index” <code>a</code> for the overall type <code>Term a</code>, not necessarily linked to a data. The type level has a life on its own. It more accurately reflect <em>static</em> information. the type of some variable, is, in a static language, part of the available information statically, but only a subset of it.</p>
<h1 id="generic-function">Generic Function</h1>
<h2 id="the-problem">The problem</h2>
<p>We want to compress data. We would like the same procedure to works for many types of data, provided its type can be described as a combination of basic types. This description could have been a type level description through with type classes, but here we have a value describing a type <code>a</code>. that value, named representation of a type will be of type <code>Type a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Type</span> a <span class="kw">where</span>
  <span class="dt">RInt</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="dt">Int</span>
  <span class="dt">RChar</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="dt">Char</span>
  <span class="dt">RList</span><span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> [a]
  <span class="dt">RPair</span><span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> b <span class="ot">-&gt;</span> <span class="dt">Type</span> (a, b)
  <span class="dt">RDyn</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="dt">Dynamic</span>
  <span class="dt">RFun</span><span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> b <span class="ot">-&gt;</span> <span class="dt">Type</span> (a <span class="ot">-&gt;</span> b)
  <span class="dt">RPerson</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="dt">Person</span>

<span class="ot">rString ::</span> <span class="dt">Type</span> <span class="dt">String</span>
rString <span class="fu">=</span> <span class="dt">RList</span> <span class="dt">RChar</span></code></pre></div>
<p>Our goal is to parameterize a function <code>compress</code> with the representation of the type of the value given. Different values yield different types for the resulting curried function</p>
<p>With all this we have access to the following magically safe operations :</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> _ <span class="fu">=</span> compress <span class="dt">RInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
<span class="ot">&gt;</span> _ <span class="fu">=</span> compress (<span class="dt">RPair</span> <span class="dt">RInt</span> <span class="dt">RChar</span>)<span class="ot"> ::</span> (<span class="dt">Int</span>, <span class="dt">Char</span>) <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</code></pre></div>
<p>(Having the compiler to find a representation for any types is the subject of <a href="https://www.seas.upenn.edu/~sweirich/papers/wadlerfest2016.pdf">a reflection on types</a> see also <a href="https://www.cis.upenn.edu/~sweirich/talks/compose16.pdf">slides</a> in ghc 8.2)</p>
<p>This is achieved in a similar way that the <code>eval</code> function</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">toBinary ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
toBinary <span class="dv">0</span> <span class="fu">=</span> []
toBinary x <span class="fu">=</span> (x <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="fu">:</span> (toBinary <span class="fu">$</span> x <span class="ot">`div`</span> <span class="dv">2</span>)

<span class="ot">toNumber&#39; ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
toNumber&#39; [] _       <span class="fu">=</span> <span class="dv">0</span>
toNumber&#39; (b <span class="fu">:</span> bs) t <span class="fu">=</span> b <span class="fu">*</span> t <span class="fu">+</span> toNumber&#39; bs (t <span class="fu">*</span> <span class="dv">2</span>)

<span class="ot">toNumber ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
toNumber <span class="fu">=</span> flip toNumber&#39; <span class="dv">1</span>

<span class="ot">padding ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
padding p x <span class="fu">=</span> <span class="kw">let</span> b <span class="fu">=</span> toBinary x
                  len <span class="fu">=</span> length b
              <span class="kw">in</span> <span class="kw">if</span> p <span class="fu">&lt;=</span> len <span class="kw">then</span> b
                 <span class="kw">else</span> b <span class="fu">++</span> take (p <span class="fu">-</span> len) (repeat <span class="dv">0</span>)

<span class="ot">compressInt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
compressInt <span class="fu">=</span> padding <span class="dv">32</span>

<span class="ot">compressChar ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
compressChar x <span class="fu">=</span> padding <span class="dv">7</span> <span class="fu">$</span> ord x

<span class="ot">compress ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
compress <span class="dt">RInt</span> x               <span class="fu">=</span> compressInt x
compress <span class="dt">RChar</span> c              <span class="fu">=</span> compressChar c
compress (<span class="dt">RList</span> _) []         <span class="fu">=</span> <span class="dv">0</span><span class="fu">:</span>[]
compress (<span class="dt">RList</span> ra) (x <span class="fu">:</span> xs)  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> compress ra x <span class="fu">++</span> compress (<span class="dt">RList</span> ra) xs
compress (<span class="dt">RPair</span> ra rb) (x, y) <span class="fu">=</span> compress ra x <span class="fu">++</span> compress rb y
compress <span class="dt">RDyn</span> (<span class="dt">Dyn</span> ra x)      <span class="fu">=</span> compressRep (<span class="dt">Rep</span> ra) <span class="fu">++</span> compress ra x
</code></pre></div>
<p>The <em>correct</em> way to see <code>compress</code> is as a <em>family</em> of functions, indexed by a value representing a type. We could index directly with a type, and get rid of the representation. This then requires type classes. Type class allow to talk about, say, <em>compressable</em> types and require that as an implicit constraint. The compiler would do for you the job of selecting the correct function from this famility with no representation being passed around. Another difference is that this selection would wire the correct function at static time and not require an interpretation at run time resulting in faster code.</p>
<h2 id="equality-comparison-..">Equality, comparison, ..</h2>
<p>To see that this is a general concept, we can provide generically other operations which are naturally thought of as <em>generic</em> : if we can compare the parts, we should be able to compare structures made of the parts.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eq ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
eq <span class="dt">RInt</span> x y <span class="fu">=</span> x <span class="fu">==</span> y
eq <span class="dt">RChar</span> x y <span class="fu">=</span> x <span class="fu">==</span> y
eq (<span class="dt">RList</span> _) [] [] <span class="fu">=</span> <span class="dt">True</span>
eq (<span class="dt">RList</span> ra) (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">|</span> eq ra x y <span class="fu">=</span> eq (<span class="dt">RList</span> ra) xs ys
                                <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">False</span>
eq (<span class="dt">RList</span> _) _ _ <span class="fu">=</span> <span class="dt">False</span>
eq (<span class="dt">RPair</span> ra rb) (x, y) (x&#39;, y&#39;) <span class="fu">=</span> eq ra x x&#39; <span class="fu">&amp;&amp;</span> eq rb y y&#39;
eq <span class="dt">RDyn</span> (<span class="dt">Dyn</span> ra x) (<span class="dt">Dyn</span> rb y) <span class="fu">=</span> <span class="kw">case</span> teq ra rb <span class="kw">of</span>
                                 <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span>
                                 <span class="dt">Just</span> f  <span class="ot">-&gt;</span> eq rb (f x) y

compare<span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>
compare <span class="dt">RInt</span> x y <span class="fu">=</span> DO.compare x y
compare <span class="dt">RChar</span> x y <span class="fu">=</span> DO.compare x y
compare (<span class="dt">RList</span> _) [] [] <span class="fu">=</span> <span class="dt">EQ</span>
compare (<span class="dt">RList</span> _) [] (_ <span class="fu">:</span> _) <span class="fu">=</span> <span class="dt">LT</span>
compare (<span class="dt">RList</span> _) (_ <span class="fu">:</span> _) [] <span class="fu">=</span> <span class="dt">GT</span>
compare (<span class="dt">RList</span> ra) (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">=</span> <span class="kw">if</span> result <span class="fu">==</span> <span class="dt">EQ</span> <span class="kw">then</span> compare (<span class="dt">RList</span> ra) xs ys
                                       <span class="kw">else</span> result
  <span class="kw">where</span> result <span class="fu">=</span> compare ra x y
compare (<span class="dt">RPair</span> ra rb) (x, y) (x&#39;, y&#39;) <span class="fu">=</span> <span class="kw">if</span> first <span class="fu">==</span> <span class="dt">EQ</span> <span class="kw">then</span> compare rb y y&#39; <span class="kw">else</span> first
  <span class="kw">where</span> first <span class="fu">=</span> compare ra x x&#39;
compare <span class="dt">RDyn</span> (<span class="dt">Dyn</span> ra x) (<span class="dt">Dyn</span> rb y) <span class="fu">=</span> <span class="kw">case</span> teq ra rb <span class="kw">of</span>
                                      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;cannot compare&quot;</span>
                                      <span class="dt">Just</span> f  <span class="ot">-&gt;</span> compare rb (f x) y</code></pre></div>
<h1 id="boosting-compress">Boosting compress</h1>
<p>compress has type <code>Type a -&gt; TCompress a</code> where <code>TCompress a = a -&gt; [Bit]</code> This type function works Compare need a value (the representation)</p>
<h1 id="the-open-world">The open world</h1>
<p>TBC</p>

]]></summary>
</entry>
<entry>
    <title>Design - part 1 - controlling export with modules and types</title>
    <link href="http://xquant.net/notes/LibraryPhantom/readme.html" />
    <id>http://xquant.net/notes/LibraryPhantom/readme.html</id>
    <published>2017-04-09T00:00:00Z</published>
    <updated>2017-04-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on April  9, 2017
    
</div>
<div class="info">
    
</div>



<p>This is a series of design strategies from <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf">fun with phantom type</a>. This is only the first part, as the paper covers a few aspects.</p>
<h1 id="raw">Raw</h1>
<p>First do everything in a single file can be a good strategy for fast results. But abstracting away can also <em>drive</em> the design, which means it pays off for itself directly upfront.</p>
<h1 id="modules-and-abstraction">Modules and abstraction</h1>
<p>Separates the service provided from the implementation, in particular the data <em>representation</em>, chosen.</p>
<p>Representation choice adresses the <em>algorithmic</em> concerns. It influence the execution, not the service provided.</p>
<p>For instance this logger shields the internal representation from its user. It only exports the type constructor <code>Logger</code> - no data constructor - and the accompanying functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">#!/usr/bin/env stack</span>
<span class="co">-- stack script --resolver lts-8.8</span>


<span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="co">-- nous faisons une librarie et gardons opaques les types</span>
<span class="co">-- son implementation est asynchone mais son interface est synchrone</span>
<span class="co">-- on utilise dans un programme/thread normal et l&#39;utilisateur n&#39;a pas</span>
<span class="co">-- a se soucier de la maniere dont c&#39;est implemente</span>
<span class="co">-- dans son utilisation, il sera impacte par notre implementation</span>
<span class="co">-- Par exemple il pourra devoir attendre s&#39;il veut poster un message et que nous ne</span>
<span class="co">-- l&#39;avons pas encore traite.</span>


<span class="kw">module</span> <span class="dt">Logger</span> (<span class="dt">Logger</span>,
               initLogger,
               logMessage,
               logStop)
    <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Control.Concurrent</span>

<span class="co">-- en *interne*, un logger est une variable partagee</span>
<span class="co">-- dans laquelle on peut ecrire / lire des commandes</span>
<span class="kw">data</span> <span class="dt">Logger</span> <span class="kw">where</span>
  <span class="dt">Logger</span><span class="ot"> ::</span> <span class="dt">MVar</span> <span class="dt">LoggerCommand</span> <span class="ot">-&gt;</span> <span class="dt">Logger</span>

<span class="kw">data</span> <span class="dt">LoggerCommand</span> <span class="kw">where</span>
   <span class="dt">Message</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">LoggerCommand</span>
   <span class="dt">Stop</span><span class="ot"> ::</span> <span class="dt">MVar</span> () <span class="ot">-&gt;</span> <span class="dt">LoggerCommand</span>

<span class="ot">initLogger ::</span> <span class="dt">IO</span> <span class="dt">Logger</span>
initLogger <span class="fu">=</span> <span class="kw">do</span>
   v <span class="ot">&lt;-</span> newEmptyMVar  <span class="co">-- et implemente selon semantique interne</span>
   <span class="kw">let</span> l <span class="fu">=</span> <span class="dt">Logger</span> v
   forkIO <span class="fu">$</span> spin l   <span class="co">-- qui est un external thread</span>
   return l


<span class="co">-- fonction interne</span>
spin l<span class="fu">@</span>(<span class="dt">Logger</span> sv) <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Started logger&quot;</span>
                        loop
  <span class="kw">where</span> loop <span class="fu">=</span> <span class="kw">do</span>
          cmd <span class="ot">&lt;-</span> takeMVar sv  <span class="co">-- on ecoute en bloquant</span>
          <span class="kw">case</span> cmd <span class="kw">of</span>
            <span class="dt">Message</span> msg <span class="ot">-&gt;</span> <span class="kw">do</span>
             putStrLn msg
             loop
            <span class="dt">Stop</span> stopv <span class="ot">-&gt;</span> <span class="kw">do</span>
             putStrLn <span class="st">&quot;Stopped logger&quot;</span>
             putMVar stopv ()
             return ()

<span class="ot">logMessage ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logMessage (<span class="dt">Logger</span> sv) msg <span class="fu">=</span> putMVar sv (<span class="dt">Message</span> msg)

<span class="ot">logStop ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logStop (<span class="dt">Logger</span> sv) <span class="fu">=</span> <span class="kw">do</span>
     stopv <span class="ot">&lt;-</span> newEmptyMVar
     putMVar sv (<span class="dt">Stop</span> stopv)
     _ <span class="ot">&lt;-</span> takeMVar stopv
     return ()


<span class="ot">test ::</span> <span class="dt">IO</span> ()
test <span class="fu">=</span> <span class="kw">do</span>
  l <span class="ot">&lt;-</span> initLogger
  logMessage l <span class="st">&quot;hello&quot;</span>
  logMessage l <span class="st">&quot;Goodbye&quot;</span>
  logStop l


<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> test</code></pre></div>
<h1 id="modules-pattern-in-haskell">Modules pattern in haskell</h1>
<p>One can add a file whose sole purpose is to perform abstraction : This file control what gets exported out, but has no code. Internal directory contains all the code and contian no export control, everything is public as far as it is concerned.</p>
<p>In <a href="https://github.com/turingjump/bookkeeper">bookeeper</a>, the file <a href="https://github.com/turingjump/bookkeeper/blob/master/src/Bookkeeper.hs">bookkeeper.hs</a> does exactly that.</p>
<p>More advanced strategies will be available with <a href="http://plv.mpi-sws.org/backpack/">backpack</a> soon</p>
<h1 id="phantom-type">Phantom type</h1>
<p>illustrating ideas from <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf">fun with phantom type</a> the commented code is from <a href="https://gist.github.com/linusyang/4057470cf96b88d13bd8">here</a></p>
<p>The name “phantom types” is motivated by the fact that no actual data is ever attached to those types. Types are usually seen as a property of some data.</p>
<p>But when looking at what we can do with types this is a wrong idea : Types stand for static knowledge of any kind.</p>
<p>Example from the <a href="https://wiki.haskell.org/Phantom_type">haskell wiki</a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- you have no *data* constructor, you can not create value of that type</span>
<span class="co">-- but you can still *talk* about that type, whose values might be handed to you</span>
<span class="kw">module</span> <span class="dt">MyAPI</span>(<span class="dt">FormData</span>, <span class="co">--type constructor</span>
             formData, <span class="co">-- smart constructor WE decide at what index values are created</span>
             validate, <span class="co">-- normal API</span>
             useData,
             lifSmallChange,
            ) <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Protolude</span>

<span class="co">-- FormData is a type constructor of kind :: * -&gt; *</span>
<span class="co">-- Given any type a of kind *, FormData a is of kind *</span>
<span class="kw">data</span> <span class="dt">FormData</span> a  <span class="kw">where</span>
  <span class="co">-- invoking the data constructor FormData with some text</span>
  <span class="co">-- creates a value of type FormData a where the CALLER chooses what a</span>
   <span class="dt">FormData</span><span class="ot"> ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">FormData</span> a

<span class="co">-- withouth data constructor, impossible for clients to</span>
<span class="co">--  - inspect what&#39;s inside a value v :: FormaData Text</span>
<span class="co">--  - build a value v :: FormData i where THEY choose i</span>
<span class="ot">changeType ::</span> <span class="dt">FormData</span> a <span class="ot">-&gt;</span> <span class="dt">FormData</span> b
changeType (<span class="dt">FormData</span> str) <span class="fu">=</span> <span class="dt">FormData</span> str


<span class="kw">data</span> <span class="dt">Validated</span>
<span class="kw">data</span> <span class="dt">Unvalidated</span>

<span class="co">-- but WE can CHOOSE whichever type</span>
<span class="ot">formData ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">FormData</span> <span class="dt">Unvalidated</span> <span class="co">-- WE decide that if you call this, the data is Unvalidated</span>
formData str <span class="fu">=</span> <span class="dt">FormData</span> str

<span class="co">-- we decide you can only ask use to consume validated data</span>
<span class="ot">useData ::</span> <span class="dt">FormData</span> <span class="dt">Validated</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
useData (<span class="dt">FormData</span> str) <span class="fu">=</span> undefined <span class="co">-- logic here</span>

<span class="co">-- that means we FORCE YOU to call this function at *some* point before</span>
<span class="ot">validate ::</span> <span class="dt">FormData</span> <span class="dt">Unvalidated</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">FormData</span> <span class="dt">Validated</span>)
validate (<span class="dt">FormData</span> str) <span class="fu">=</span> undefined <span class="co">-- logic here</span>


<span class="co">-- benign operation</span>
<span class="ot">liftSmallChange ::</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>) <span class="ot">-&gt;</span> <span class="dt">FormData</span> a <span class="ot">-&gt;</span> <span class="dt">FormData</span> a
liftSmallChange <span class="fu">=</span> undefined <span class="co">-- logic which only touch small stuff</span>


<span class="co">-- big operation - you have to revalidate !</span>
<span class="ot">liftBigChange ::</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>) <span class="ot">-&gt;</span> <span class="dt">FormData</span> a <span class="ot">-&gt;</span> <span class="dt">FormData</span> <span class="dt">Unvalidated</span>
liftBigChange <span class="fu">=</span> undefined <span class="co">-- logic which can touch anything</span></code></pre></div>
<p>with this, we separate validation from action, and prevent you from tampering after it’s validated, while still allowing you maximum freedom in how you operate. we keep control, you keep freedom</p>
<h1 id="middleware-pattern">Middleware pattern</h1>
<p>one direct example of this is the middleware pattern</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Middleware</span>(<span class="dt">EndForYou</span>, <span class="co">-- type constructor</span>
                  serve      <span class="co">-- run your application</span>
            ) <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Protolude</span>

<span class="kw">data</span> <span class="dt">EndForYou</span> <span class="kw">where</span>
   <span class="dt">TheEndCtor</span><span class="ot"> ::</span> <span class="dt">EndForYou</span>


app0 <span class="fu">=</span><span class="ot"> undefined ::</span> response
app1 <span class="fu">=</span><span class="ot"> undefined ::</span> (response <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>) <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>
app2 <span class="fu">=</span><span class="ot"> undefined ::</span> input <span class="ot">-&gt;</span> (response <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>) <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>


<span class="kw">type</span> <span class="dt">Application</span> input response m <span class="fu">=</span> input <span class="ot">-&gt;</span> (response <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>) <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>

<span class="ot">serve ::</span> <span class="dt">Application</span> input output m <span class="ot">-&gt;</span> input <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>
serve yourServer input <span class="fu">=</span> (yourServer input) process
  <span class="kw">where</span> process response <span class="fu">=</span> undefined <span class="co">-- actually sends the response</span>


<span class="co">-- cote client il y aura</span>
<span class="ot">receive ::</span> response <span class="ot">-&gt;</span> next
receive <span class="fu">=</span> undefined
</code></pre></div>
<h1 id="types-at-work">Types at Work</h1>
<p>Types are nice, but in haskell they are not just decoration and checking. They are PART of the code, they DECIDE what to do. “Type is data”</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Sanitise</span> a <span class="kw">where</span>
<span class="ot">  sanitise ::</span> <span class="dt">FormData</span> a <span class="ot">-&gt;</span> <span class="dt">FormData</span> <span class="dt">Validated</span>

<span class="co">-- do nothing to data that is already validated</span>
<span class="kw">instance</span> <span class="dt">Sanitise</span> <span class="dt">Validated</span> <span class="kw">where</span>
  sanitise <span class="fu">=</span> identity

<span class="co">-- sanitise untrusted data</span>
<span class="kw">instance</span> <span class="dt">Sanitise</span> <span class="dt">Unvalidated</span> <span class="kw">where</span>
  sanitise (<span class="dt">FormData</span> str) <span class="fu">=</span> <span class="dt">FormData</span> (filter isAlpha str) <span class="kw">where</span> filter <span class="fu">=</span> undefined
                                                                isAlpha <span class="fu">=</span> undefined


a <span class="fu">=</span> <span class="dt">FormData</span> <span class="st">&quot;Hello&quot;</span>

<span class="co">-- the type chooses what will be done !</span>
_ <span class="fu">=</span> sanitise (<span class="ot">a ::</span> <span class="dt">FormData</span> <span class="dt">Unvalidated</span>)
_ <span class="fu">=</span> sanitise (<span class="ot">a ::</span> <span class="dt">FormData</span> <span class="dt">Validated</span>)

<span class="co">-- if it can&#39;t, it&#39;s an error, just like a syntax error</span>
_ <span class="fu">=</span> sanitise a <span class="co">-- error !</span></code></pre></div>

]]></summary>
</entry>
<entry>
    <title>Test post, let's draw stuff</title>
    <link href="http://xquant.net/notes/cats1and2/readme.html" />
    <id>http://xquant.net/notes/cats1and2/readme.html</id>
    <published>2017-03-27T00:00:00Z</published>
    <updated>2017-03-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on March 27, 2017
    
</div>
<div class="info">
    
</div>



<p>Just a test post to see if things work</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; example1 ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">&gt;</span> example1 <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fc red
<span class="ot">&gt;</span>                    <span class="fu">#</span> lw veryThick
<span class="ot">&gt;</span>                    <span class="fu">#</span> lc black
<span class="ot">&gt;</span>                    <span class="fu">#</span> dashingG [<span class="fl">0.2</span>,<span class="fl">0.05</span>] <span class="dv">0</span></code></pre></div>
<p>Diagram from above : <img src="static/example1.svg" /></p>
<p>Or from some library :</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> out11 <span class="fu">=</span><span class="ot"> example11 ::</span> <span class="dt">Diagram</span> <span class="dt">B</span></code></pre></div>
<div class="figure">
<img src="static/out11.svg" />

</div>
<p>which means we can go deep with some project, using standard tools, and then provide a good summary of the artefact it can produce</p>

]]></summary>
</entry>
<entry>
    <title>2017-03-23-Weekly-links</title>
    <link href="http://xquant.net/weekly/2017-03-23-Weekly-links.html" />
    <id>http://xquant.net/weekly/2017-03-23-Weekly-links.html</id>
    <published>2017-03-23T00:00:00Z</published>
    <updated>2017-03-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2017-03-23</h1>
<!-- <aside>Posted on 2017-03-23</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://gist.github.com/RockyRoad29/bd4ca6fdb41196a71662986f809e2b1c" >Emacs loaded packages exploration tools</a>
    </dt>
    <dd>Exploring your loaded emacs libraries (spacemacs)<br></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://quantomatic.github.io/" >Quantomatic :: Home</a>
    </dt>
    <dd>Quantomatic is a diagrammatic proof assistant, meaning it provides machine-support for reasoning with diagrammatic languages</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://research.microsoft.com/en-us/um/people/daan/madoko/doc/reference.html#sec-installation-and-usage" >Madoko Reference</a>
    </dt>
    <dd>Madoko is a fast javascript Markdown processor written in Koka It started out as a demo program for the new, strongly typed, Koka language and the name comes from “Markdown in Koka”.<br></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://hackage.haskell.org/package/brick" >brick: A declarative terminal user interface library</a>
    </dt>
    <dd>Write terminal applications painlessly with brick! You write an event handler and a drawing function and the library does the rest.<br></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://kseo.github.io/posts/2017-01-28-build-your-haskell-project-continuously.html" >Kwang&#39;s Haskell Blog - Build your Haskell project continuously</a>
    </dt>
    <dd>Build your Haskell project continuously<br></dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>Directed Acyclic Graphs</title>
    <link href="http://xquant.net/notes/graphvalue/readme.html" />
    <id>http://xquant.net/notes/graphvalue/readme.html</id>
    <published>2017-02-03T00:00:00Z</published>
    <updated>2017-02-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on February  3, 2017
    
</div>
<div class="info">
    
</div>



<h5 id="section"></h5>
<hr />
<h2 id="representing-graphs">Representing graphs</h2>
<p>There are a few ways to represent a graph:</p>
<ul>
<li>as a list of Nodes and a list of edges</li>
<li>as a list of neighbors</li>
</ul>
<p>each representation is optimized for a runtime behaviour (cf Kormen) but it’s useful to abstract representation to express operations. A convenient way to abstract over those representations is shown in <a href="https://scholar.google.fr/scholar?cluster=6598618604128829558&amp;hl=en&amp;as_sdt=0,5&amp;sciodt=0,5">Fun with type function</a></p>
<p>But what if we could abuse haskell somehow to represent graph not with some external description but with haskell itself ?</p>
<hr />
<h2 id="breaking-referential-transparency">Breaking referential transparency</h2>
<p>We want to write graph that way</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; graph1 ::</span> <span class="dt">Tree</span> <span class="dt">IntTreeF</span>
<span class="ot">&gt;</span> graph1 <span class="fu">=</span> iNode (iNode (iLeaf <span class="dv">2</span>) a) b
<span class="ot">&gt;</span>            <span class="kw">where</span> a <span class="fu">=</span> iNode (iNode (iLeaf <span class="dv">2</span>)(iLeaf <span class="dv">2</span>)) (iLeaf <span class="dv">2</span>)
<span class="ot">&gt;</span>                  b <span class="fu">=</span> a</code></pre></div>
<p>instead of some variation of</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- graph1&#39; = mkDag (Node (Node (Leaf 2) (Ref 0)) (Ref 0)) [(0, Node (Node (Leaf 2) (Leaf 2)) (Leaf 2))]</span></code></pre></div>
<p>But normally, in Haskell there should be no way to distinguish graph1 from</p>
<p>from</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; graph2 ::</span> <span class="dt">Tree</span> <span class="dt">IntTreeF</span>
<span class="ot">&gt;</span> graph2 <span class="fu">=</span>  iNode (iNode (iLeaf <span class="dv">2</span>) a) b
<span class="ot">&gt;</span>            <span class="kw">where</span> a <span class="fu">=</span> iNode (iNode (iLeaf <span class="dv">2</span>) (iLeaf <span class="dv">2</span>)) (iLeaf <span class="dv">2</span>)
<span class="ot">&gt;</span>                  b <span class="fu">=</span> iNode (iNode (iLeaf <span class="dv">2</span>) (iLeaf <span class="dv">2</span>)) (iLeaf <span class="dv">2</span>)</code></pre></div>
<p>But we can actually abuse haskell by going to <code>IO</code> and relying on some implementation of GHC to observe the sharing using <a href="https://scholar.google.fr/scholar?cluster=13707349448701947240&amp;hl=en&amp;as_sdt=0,5&amp;sciodt=0,5">Type-safe observable sharing in Haskell</a> a technique implemented and extended in <a href="http://hackage.haskell.org/package/data-reify">data-reify</a></p>
<p>With this we can produce two different output for two values which <em>should have been</em> be undistinguishable.</p>
<table>
<thead>
<tr class="header">
<th align="center">graph1</th>
<th align="center">graph2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="static/graph1.svg" /></td>
<td align="center"><img src="static/graph2.svg" /></td>
</tr>
</tbody>
</table>
<p>basically the second graph is maximal sharing of subnodes. because we only ever use names like a and b once, they are irrelevant. whereas in the first case, this bottom leaf 2 is not really <em>any</em> leaf 2, it is the leaf which comes from <code>a</code> which should also be equal to <code>b</code> as a graph. to make sure they are equal, the equivalent relation a = b gets its own private copy which is not shared with other subgraphs.</p>
<p>using this we can directly represent graphs with haskell which is convienent and more visual than labeling nodes. indeed compare the code, visual, with the following ‘normal’ representation of first and second example.</p>
<p>T</p>
<ul>
<li>traversals (control - cps, mendler, launchbury coroutining fold)</li>
<li>names (polymorphism)</li>
<li>regions (applicative batching, compdata)</li>
</ul>

]]></summary>
</entry>
<entry>
    <title>2017-01-16-Weekly-links</title>
    <link href="http://xquant.net/weekly/2017-01-16-Weekly-links.html" />
    <id>http://xquant.net/weekly/2017-01-16-Weekly-links.html</id>
    <published>2017-01-16T00:00:00Z</published>
    <updated>2017-01-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2017-01-16</h1>
<!-- <aside>Posted on 2017-01-16</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://knsv.github.io/mermaid/#mermaid" >mermaid - Generation of diagrams and flowcharts from text in a similar manner as markdown.</a>
    </dt>
    <dd></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://downloads.haskell.org/%7Eghc/master/users-guide/glasgow_exts.html#ghc-flag--XTypeApplications" >9.1. Language options — Glasgow Haskell Compiler &lt;release&gt; Users Guide</a>
    </dt>
    <dd>For example, we can have pair :: forall a. a -&gt; forall b. b -&gt; (a, b) and then say pair @Bool True @Char which would have type Char -&gt; (Bool, Char).</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/cies/htoml" >cies/htoml: TOML file format parser in Haskell</a>
    </dt>
    <dd>A TOML parser library in Haskell.<br><br>TOML is the obvious, minimal configuration language by Tom Preston-Werner. It is an alternative to the XML, YAML and INI formats mainly for the purpose of configuration files. Many will find that XML and YAML are too heavy for the purpose of configuration files prupose while INI is underspecified. TOML is to configuration files, like what Markdown is for rich-text.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/kcsongor/register-machine-type" >kcsongor/register-machine-type: Universal Register Machine implemented at the type-level of Haskell</a>
    </dt>
    <dd>Initialises R1 to 5, then raises 2 to the power of the value of R1, leaving the result (32) in R0. Uses R2 as a scratch register, thus the machine is initialised with 3 registers.<br><br>pow2 :: (&#39;Halted a (r &#39;: rs) ~<br>            Run<br>              &#39;[<br>              -- Instr              | label index<br>              -- set R1 to 5<br>                Inc (R 1) (L 1)             -- 0<br>              , Inc (R 1) (L 2)             -- 1<br>              , Inc (R 1) (L 3)             -- 2<br>              , Inc (R 1) (L 4)             -- 3<br>              , Inc (R 1) (L 5)             -- 4<br>              -- set R0 to 1<br>              , Inc (R 0) (L 6)             -- 5<br>              -- R0 = 2^R1<br>              , Dec (R 1) (L 7) (L 12)      -- 6<br>              -- R2 = R0<br>              , Dec (R 0) (L 8) (L 9)       -- 7<br>              , Inc (R 2) (L 7)             -- 8<br>              -- R0 = 2*R2<br>              , Dec (R 2) (L 10) (L 6)      -- 9<br>              , Inc (R 0) (L 11)            -- 10<br>              , Inc (R 0) (L 9)             -- 11<br><br>              , Halt                        -- 12<br>              ]) =&gt; Proxy r<br>pow2 = Proxy</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/mikeizbicki/subhask/blob/master/examples/example0001-polynomials.lhs" >subhask/example0001-polynomials.lhs at master ·よ mikeizbicki/subhask</a>
    </dt>
    <dd>&gt;   let f :: Ring x =&gt; x -&gt; x<br>&gt;       f x = x*x*x + x + 3<br>&gt;<br>&gt;   let a = 3 :: Integer<br>&gt;<br>&gt;   putStrLn $ &quot;f a = &quot; + show (f a)<br><br>Now, we&#39;ll create a polynomial from our ordinary function.<br><br>&gt;   let g :: Polynomial Integer<br>&gt;       g = provePolynomial f<br>&gt;<br>&gt;   putStrLn &quot;&quot;<br>&gt;   putStrLn $ &quot;g $ a = &quot; + show ( g $ a )<br><br>Polynomials support operations that other functions in Hask do not support.<br>For example, we can show the value of a polynomial:<br>&gt;   putStrLn &quot;&quot;<br>&gt;   putStrLn $ &quot;g     = &quot; + show g<br>&gt;   putStrLn $ &quot;g*g+g = &quot; + show (g*g + g)</dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>2017-01-02-Weekly-links</title>
    <link href="http://xquant.net/weekly/2017-01-02-Weekly-links.html" />
    <id>http://xquant.net/weekly/2017-01-02-Weekly-links.html</id>
    <published>2017-01-02T00:00:00Z</published>
    <updated>2017-01-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2017-01-02</h1>
<!-- <aside>Posted on 2017-01-02</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/mikeizbicki/subhask/blob/master/examples/example0001-polynomials.lhs" >subhask/example0001-polynomials.lhs at master · mikeizbicki/subhask</a>
    </dt>
    <dd>&gt;   let f :: Ring x =&gt; x -&gt; x<br>&gt;       f x = x*x*x + x + 3<br>&gt;<br>&gt;   let a = 3 :: Integer<br>&gt;<br>&gt;   putStrLn $ &quot;f a = &quot; + show (f a)<br><br>Now, we&#39;ll create a polynomial from our ordinary function.<br><br>&gt;   let g :: Polynomial Integer<br>&gt;       g = provePolynomial f<br>&gt;<br>&gt;   putStrLn &quot;&quot;<br>&gt;   putStrLn $ &quot;g $ a = &quot; + show ( g $ a )<br><br>Polynomials support operations that other functions in Hask do not support.<br>For example, we can show the value of a polynomial:<br>&gt;   putStrLn &quot;&quot;<br>&gt;   putStrLn $ &quot;g     = &quot; + show g<br>&gt;   putStrLn $ &quot;g*g+g = &quot; + show (g*g + g)</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://www.fpcomplete.com/haskell-syllabus" >A Haskell Study Syllabus :: FP Complete</a>
    </dt>
    <dd>A Haskell Study Syllabus<br>Learn professional-grade Haskell coding practices quickly and efficiently</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://www.fstar-lang.org/tutorial/tutorial.html#sec-stateful-access-control" >Verified programming in F*</a>
    </dt>
    <dd>A hyper-heap provides organizes the heap into many disjoint fragments, or regions. Each region is collectively addressed by a region identifier, and these identifiers are organized in a tree-shaped hierarchy. Each region is itself a map from typed references to values, just like our heaps from before. The picture below depicts the structure.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://wiki.haskell.org/Bracket_pattern" >Bracket pattern - HaskellWiki</a>
    </dt>
    <dd>When acquiring, using, and releasing various resources, it can be quite convenient to write a function to manage the acquisition and releasing, taking a function of the acquired value that specifies an action to be performed in between.ほ</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://notes.pinboard.in/u:nrolland/e8f4196a4ae627475f38" >restart server whenever a new file is created in the .stack-work bin folder</a>
    </dt>
    <dd>If you&#39;re on Linux, you can install inotify-tools, run stack build --file-watch in one terminal and<br><br>(<br>  declare -i p<br>  trap &#39;kill &quot;$p&quot;&#39; EXIT<br>  while true; do<br>    stack exec server arg1 arg2  &amp; ...</dd>
    </div>
    
</article>
]]></summary>
</entry>

</feed>
