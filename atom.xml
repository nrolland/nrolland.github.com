<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>xQuant</title>
    <link href="http://xquant.net/atom.xml" rel="self" />
    <link href="http://xquant.net" />
    <id>http://xquant.net/atom.xml</id>
    <author>
        <name>Nicolas Rolland</name>
        <email></email>
    </author>
    <updated>2018-07-20T00:00:00Z</updated>
    <entry>
    <title>2018-07-20-Weekly-links</title>
    <link href="http://xquant.net/weekly/2018-07-20-Weekly-links.html" />
    <id>http://xquant.net/weekly/2018-07-20-Weekly-links.html</id>
    <published>2018-07-20T00:00:00Z</published>
    <updated>2018-07-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2018-07-20</h1>
<!-- <aside>Posted on 2018-07-20</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://www.youtube.com/watch?v=Urff1ce--wU&amp;list=PLgKuh-lKre13er04z8os0MxwPPiY5VspR&amp;index=29" >A Compositional Quantum Programming Language - YouTube</a>
    </dt>
    <dd>Quipper is a high-level functional programming language for quantum computing</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://varianto25.com/news" >Varianto:25</a>
    </dt>
    <dd>git:deck is a unique playing cards deck, where each individual card contains a useful Git command and a brief description explaining it.<br></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://web.hypothes.is/" >Hypothesis ‚Äì The Internet, peer reviewed.</a>
    </dt>
    <dd>Annotate the web, with anyone, anywhere.<br>We‚Äôre a nonprofit on a mission to bring an open conversation over the whole web. Use Hypothesis right now to hold discussions, read socially, organize your research, and take personal notes</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://liberapay.com/" >Liberapay</a>
    </dt>
    <dd>Liberapay is a recurrent donations platform.<br><br>We help you fund the creators and projects you appreciate.<br></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://www.muvi.com/blogs/stop-youtubing-videos-free.html" >Stop YouTubing your Videos for Free!!! - Muvi</a>
    </dt>
    <dd>You‚Äôre spending in sending traffic to YouTube, not Your Service<br>Your entire marketing campaign is based on driving your potential viewrs to YouTube.com/YourBrand. When you market your YouTube channel, you actually send FREE traffic to YouTube. Your viewers will go to YouTube first and then search for your content/channel, which means YouTube getting free marketing on your expense! Are you sure you want to promote someone else‚Äôs brand for Free?</dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>Notes - typerole</title>
    <link href="http://xquant.net/notes/typerole/readme.html" />
    <id>http://xquant.net/notes/typerole/readme.html</id>
    <published>2018-06-03T00:00:00Z</published>
    <updated>2018-06-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on June  3, 2018
    
</div>
<div class="info">
    
</div>


<p>from <a href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf">Generative Type Abstraction and Type-level Computation - weirich vytiniotis spj zdancewic</a></p>
<h1 id="motivation-personelle">Motivation personelle</h1>
<p>Comment raffiner une theorie en gardant en interne le fait que deux operations doivent etre egales, et en forcant les clients a travailler sans cette egalite. Cette question revient frequemment : on remplace une egalite (qui est une idee platonicienne, existant de toute eternite) par un isomorphisme (qui est une fonction, qui a un nom, qui peut etre passse en argument).</p>
<p>On en voit une autre illustration dans les types de Haskell, ou attribuer des noms differents a des structures identiques force les clients a distinguer et a referencer explicitement des isos pour passer d‚Äôun type a un autre.</p>
<p>Nous regardons donc comment c‚Äôest traite dans le papier mentionne</p>
<h1 id="introduction">Introduction</h1>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Age</span> <span class="fu">=</span> <span class="dt">MkAge</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">K</span> a <span class="kw">where</span>
<span class="ot">&gt;</span>   <span class="dt">KAge</span><span class="ot"> ::</span> <span class="dt">K</span> <span class="dt">Age</span>
<span class="ot">&gt;</span>   <span class="dt">KInt</span><span class="ot"> ::</span> <span class="dt">K</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; cvt ::</span> <span class="ot">‚àÄ</span> c<span class="fu">.</span> c <span class="dt">Int</span> <span class="ot">‚Üí</span> c <span class="dt">Age</span>
<span class="ot">&gt;</span> cvt x <span class="fu">=</span> undefined <span class="co">-- identite : an Age is an Int</span></code></pre></div>
<p>remarque interessante sur les modules dans ML, ou DANS un module, on Age et Int sont <em>vraiment</em> synonymes.</p>
<h2 id="trouble-in-paradise">trouble in paradise</h2>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; kint ::</span> <span class="dt">K</span> <span class="dt">Age</span>
<span class="ot">&gt;</span> kint <span class="fu">=</span> cvt <span class="dt">KInt</span> <span class="co">-- the representation is the same</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; get ::</span> <span class="dt">K</span> <span class="dt">Age</span> <span class="ot">‚Üí</span> <span class="dt">Bool</span> <span class="co">-- only defined at K Age</span>
<span class="ot">&gt;</span> get <span class="dt">KAge</span> <span class="fu">=</span> <span class="dt">True</span>     <span class="co">-- so this pattern match is exhaustive</span></code></pre></div>
<p>yet this will fail :</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> vf <span class="fu">=</span> get kint</code></pre></div>
<p>(flash news : le domaine d‚Äôune fonction fait partie de sa definition. fonction identite agit uniformement, mais l‚Äôidentite en A n‚Äôest pas l‚Äôidentite en B. si les noms ont de l‚Äôimportance, ca ne passe pas sans preuve que A = B, preuve detenue uniquement <em>en interne</em> par la personne ayant cree le newtype.)</p>
<h2 id="more-trouble">more trouble</h2>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> family <span class="dt">F</span><span class="ot"> a ::</span> <span class="fu">*</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Age</span> <span class="fu">=</span> <span class="dt">Char</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">Bool</span></code></pre></div>
<p>Permet de deduire :</p>
<ul>
<li>Bool ~ F Int</li>
<li>F Int ~ F Age</li>
<li>F Age ~ Char</li>
<li>=&gt; Bool ~ Char (!?)</li>
</ul>
<p>‚ÄúWhat went wrong? Maybe it should be illegal for a type function to behave differently on two coercible types, such as Age and Int? But in fact Haskell programmers often use newtypes precisely so that they can give a different type-class instance (for comparison, say) for Age than for the underlying Int. Type functions are no different;‚Äù</p>
<p>On se sert des types synomymes pour introduire des NOMS. ces noms ne doivent pas etre identifies pour les CLIENTS de ces noms. Les type functions, type classes sont clients, il faut leur cacher l‚Äôequation en notre possession (Age = Int).</p>
<h2 id="yet-more-trouble">yet more trouble</h2>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">TF</span> a <span class="fu">=</span> <span class="dt">MkTF</span> (<span class="dt">F</span> a)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; to ::</span> <span class="dt">Bool</span><span class="ot">‚Üí</span> <span class="dt">TF</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> to b <span class="fu">=</span> <span class="dt">MkTF</span> b
<span class="ot">&gt;</span> 
<span class="ot">&gt; from ::</span> <span class="dt">TF</span> <span class="dt">Age</span><span class="ot">‚Üí</span> <span class="dt">Char</span>
<span class="ot">&gt;</span> from (<span class="dt">MkTF</span> c) <span class="fu">=</span> c</code></pre></div>
<p>this will fail</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> vf2 <span class="fu">=</span> from <span class="fu">.</span> cvt <span class="fu">.</span> to</code></pre></div>
<p>cvt utilise une preuve qui doit rester privee. a l‚Äôexterieur, les differences de noms doivent creer des differences</p>
<p>‚ÄúThis problem is important .. because the same issues will arise in any type system that combines type-level dispatch and coercion lifting.‚Äù</p>
<p>Coercion lifting : if for two types œÜ and œà we have œÜ ‚àº œà (for example, if they are the abstract and concrete types of a newtype declaration), then T œÜ ‚àº T œà for any type constructor T .</p>
<p>qui n‚Äôest valable que d‚Äôun point de vue INTERNE ou les noms n‚Äôont pas d‚Äôimportance</p>
<h1 id="fc2">FC2</h1>
<p>‚Ä¢ On peut voir Age et Int comme deux noms differents =&gt; ‚Äúwe can view Age and IntCode as two different codes that both map to the type Int‚Äù</p>
<p>‚Ä¢ ‚Äúthe important distinction between codes and types is that they have different definitions of equality. In the encoding above, the codes Age and IntCode are different codes, but their interpretations are equal types‚Äù differentes definition de l‚Äôegalite, surtout preuves privees VS preuves publique. JE peux decider de creer deux noms que moi seul peut identifier. TU es force de penser qu‚Äôils sont distincts. ce qui se passe avec les types abstraits et les valeurs, se passe aussi pour les fonctions de types et le systeme logique.</p>
<p>‚Ä¢ ‚ÄúAge and Int are distinct when viewed at role code but equal when viewed at role type. Code equality is used to reason about the meaning of type-indexed functions and is finer-grained than type equality, which is used to determine which type coercions are safe‚Äù</p>
<p>‚Äúrole type‚Äù : role dieu de la phase compilation, qui ne voit que l‚Äôutilisation finale : c‚Äôest un Int ou c‚Äôest un Bool ? Les autres subtilites sont detruites. Je peux devenir un dieu local et forcer mes clients a faire une distinction que moi seul peut lever, mais je reste soumis a mon dieu (qui identifie les types).</p>
<p>on a une hierarchie de dieu, et une relation d‚Äôordre.</p>
<h2 id="description-de-fc2">Description de FC2</h2>
<p>FC2 is ex- pressive enough to capture indexed type functions, newtype and newtype deriving,GADTs,existentialandnesteddatatypes, and much more.</p>
<p>First, FC2 provides polymorphic datatypes,</p>
<p>Second, FC2 includes first-class proofs of type equality that witness safe coercions introduced during compilation</p>
<h2 id="syntax-directed-typechecking">Syntax directed typechecking</h2>
<p>Programs in FC2 can abstract over coercions reflecting a particular type equal- ity (written Œõc : œÜ1 ‚àº œÜ2.e), pass a coercion as an argument to such a function (written e Œ≥), and use a coercion to cast a term from one type to another (written e ‚óÉ Œ≥). These explicit coercions, written Œ≥, make typechecking FC2 programs syntax-directed.</p>
<p><strong>The syntax of an FC2 term encodes its typing derivation</strong></p>
<p>Why is this important?</p>
<p>‚Ä¢ The idea is that the compiler‚Äôs front end performs perhaps-complex type inference on the source program, and records the proofs generated by inference directly in the syntax of the FC2 intermediate language.</p>
<p>‚Ä¢ The optimiser transforms FC2 terms, perhaps radically.</p>
<p>At any point one can check the consistency of the resulting FC2 program using a simple, fast, syntax- directed typechecker; this consistency check has proven to be an extremely powerful aid to getting the compiler right. It is just as easy to find the type of an arbitrary FC2 term, an ability that is used extensively inside GHC.</p>
<p>Ma syntaxe reflete parfaitement la construction des proprietes logiques dont je veux parler, et toute l‚Äôinformation pour retrouver/verifier un propriete est dans mon terme, avec toutes les etapes intermediaires</p>
<h2 id="fc2-types-and-kinds">FC2 types and kinds</h2>
<p>Types in FC2 are classified by pairs Œ∫ of the form Œ∑/R, where :</p>
<p>‚Ä¢ the kind Œ∑ ensures (as usual) that types are well-formed structurally</p>
<p>‚Ä¢ the role R that determines the precision at which they can be analyzed.</p>
<p>Codes (which distinguish Age and Int) have role C, whereas types (which identify them) have role T.</p>
<p>Par exemple :</p>
<p>The distinction between codes and types allows us to give infor- mative kinds to type constructors:</p>
<p>‚Ä¢ The Maybe type (Section 2.1) has kind ‚ãÜ/T ‚Üí ‚ãÜ, indicating that Maybe treats its argument parametrically (les proprietes logiques de Maybe s‚Äôexpriment via le dieu compilation, et s‚Äôimposent a tous)</p>
<p>‚Ä¢ The types K, F, and TF (Section 2.2) all use type indexing and therefore have kind ‚ãÜ/C ‚Üí ‚ãÜ. (les proprietes de logiques de )</p>
<p>These kinds in turn support the key insight of this paper: <strong>it is only safe to lift coercions through functions with parametric kinds</strong></p>
<p>So Maybe Age ‚àº Maybe Int holds but TF Age Ã∏‚àº TF Int.</p>
<p>Parce que Maybe se refere au dieu compilation qui s‚Äôimpose aux autres dieux locaux, qui ne sont que des intercesseurs. Tandis que les TF sont des clients de Dieux non precises, potentiellement autres que celui de la compilation</p>
]]></summary>
</entry>
<entry>
    <title>2018-05-31-Weekly-links</title>
    <link href="http://xquant.net/weekly/2018-05-31-Weekly-links.html" />
    <id>http://xquant.net/weekly/2018-05-31-Weekly-links.html</id>
    <published>2018-05-31T00:00:00Z</published>
    <updated>2018-05-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2018-05-31</h1>
<!-- <aside>Posted on 2018-05-31</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://custodians.online/" >In Solidarity with Library Genesis and Sci-hub</a>
    </dt>
    <dd>There are many businessmen who own knowledge today. Consider Elsevier, the largest scholarly publisher, whose 37% profit margin1 stands in sharp contrast to the rising fees, expanding student loan debt and poverty-level wages for adjunct faculty. Elsevier owns some of the largest databases of academic material, which are licensed at prices so scandalously high that even Harvard, the richest university of the global north, has complained that it cannot afford them any longer. Robert Darnton, the past director of Harvard Library, says &quot;We faculty do the research, write the papers, referee papers by other researchers, serve on editorial boards, all of it for free ‚Ä¶ and then we buy back the results of our labour at outrageous prices.&quot;2 For all the work supported by public money benefiting scholarly publishers, particularly the peer review that grounds their legitimacy, journal articles are priced such that they prohibit access to science to many academics - and all non-academics - across the world, and render it a token of privilege.3</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/jasonmorton/Cateno/blob/master/demo/ThreeQubitsFTS.ipynb" >string diagram generation for monoidal categories</a>
    </dt>
    <dd>Cateno is a system for computational category theory and applications. It provides an interactive calculator for free morphism expressions and string diagram generation for monoidal categories. It also handles concrete categories, and can be used as a typed numerical linear algebra system.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://mybinder.org/" >Binder (beta)</a>
    </dt>
    <dd>Have a repository full of Jupyter notebooks? With Binder, open those notebooks in an executable environment, making your code immediately reproducible by anyone, anywhere.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/Gabriel439/slides/blob/master/nix-internals/slides.md" >slides/slides.md at master ¬∑ Gabriel439/slides</a>
    </dt>
    <dd>Nix: under the hood % Gabriel Gonzalez % December 7, 2017<br></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://videolectures.net/gpip06_bletchley_park/" >Gaussian Processes in Practice Workshop</a>
    </dt>
    <dd> Bletchley Park 2006 - VideoLectures - VideoLectures.NET</dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>2017-12-03-Weekly-links</title>
    <link href="http://xquant.net/weekly/2017-12-03-Weekly-links.html" />
    <id>http://xquant.net/weekly/2017-12-03-Weekly-links.html</id>
    <published>2017-12-03T00:00:00Z</published>
    <updated>2017-12-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2017-12-03</h1>
<!-- <aside>Posted on 2017-12-03</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/zeit/release" >zeit/release: Generate changelogs with a single command</a>
    </dt>
    <dd>When run, this command line interface automatically generates a new GitHub Release and populates it with the changes (commits) made since the last release.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/danidiaz/streamy" >danidiaz/streamy: Using Backpack to abstract over the main Haskell streaming libraries.</a>
    </dt>
    <dd>Using Backpack to abstract over the main Haskell streaming libraries.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/typicode/hotel" >typicode/hotel: A simple process manager for developers. Start apps from your browser and access them using local .dev domains</a>
    </dt>
    <dd>üè© A simple process manager for developers. Start apps from your browser and access them using local .dev domains</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://storybook.js.org/examples/" >https://storybook.js.org/examples/</a>
    </dt>
    <dd>Storybook Examples<br><br>We write a few stories for our todo list component‚Äôs different states.<br>Then you can interact with them inside React Storybook</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://runkit.com/explore" >RunKit: Example Notebooks</a>
    </dt>
    <dd>Explore RunKit<br>See the interesting things people are creating with RunKit.</dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>2017-10-26-Weekly-links</title>
    <link href="http://xquant.net/weekly/2017-10-26-Weekly-links.html" />
    <id>http://xquant.net/weekly/2017-10-26-Weekly-links.html</id>
    <published>2017-10-26T00:00:00Z</published>
    <updated>2017-10-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2017-10-26</h1>
<!-- <aside>Posted on 2017-10-26</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://plzoo.andrej.com/" >The Programming Languages Zoo</a>
    </dt>
    <dd>The Programming Languages Zoo is a collection of miniature programming languages which demonstrates various concepts and techniques used in programming language design and implementation. It is a good starting point for those who would like to implement their own programming language, or just learn how it is done.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/psibi/dhall-mode" >psibi/dhall-mode</a>
    </dt>
    <dd>Emacs Major mode for working with Dhall configuration language</dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>2017-09-18-Weekly-links</title>
    <link href="http://xquant.net/weekly/2017-09-18-Weekly-links.html" />
    <id>http://xquant.net/weekly/2017-09-18-Weekly-links.html</id>
    <published>2017-09-18T00:00:00Z</published>
    <updated>2017-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1>Weekly links for 2017-09-18</h1>
<!-- <aside>Posted on 2017-09-18</aside> -->
<article>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://www.lamdu.org/" >Lamdu</a>
    </dt>
    <dd>This project aims to create a next-generation live programming environment that radically improves the programming experience</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/firehol/netdata" >firehol/netdata: Get control of your servers. Simple. Effective. Awesome! https://my-netdata.io/</a>
    </dt>
    <dd>netdata is a system for distributed real-time performance and health monitoring. It provides unparalleled insights, in real-time, of everything happening on the system it runs (including applications such as web and database servers), using modern interactive web dashboards.</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://www.autodeskresearch.com/publications/samestats" >Same Stats, Different Graphs: Generating Datasets with Varied Appearance and Identical Statistics through Simulated Annealing | Autodesk Research</a>
    </dt>
    <dd></dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="http://distill.pub/2017/momentum/" >Why Momentum Really Works</a>
    </dt>
    <dd>Really nice illustrated mathematics on the web</dd>
    </div>
    
    <div class="bookmark">
    <dt class="bookmark_title">
     <a href="https://github.com/sweirich/pi-forall" >sweirich/pi-forall: A demo implementation of a simple dependently-typed language</a>
    </dt>
    <dd>Pi-Forall language<br><br>This language implementation is designed to accompany four lectures at OPLSS during Summer 2014. Notes for these lectures are included in the distribution:<br></dd>
    </div>
    
</article>
]]></summary>
</entry>
<entry>
    <title>Design - part 2 - Putting types to work</title>
    <link href="http://xquant.net/notes/TypeRep/readme.html" />
    <id>http://xquant.net/notes/TypeRep/readme.html</id>
    <published>2017-04-12T00:00:00Z</published>
    <updated>2017-04-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on April 12, 2017
    
</div>
<div class="info">
    
</div>



<p>Where we venture into using types as drivers, not just as verifiers.</p>
<p>illustrating ideas from <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf">fun with phantom type</a> the commented code is from <a href="https://gist.github.com/linusyang/4057470cf96b88d13bd8">here</a></p>
<h1 id="warmup---interpreter">Warmup - Interpreter</h1>
<p>If we represent a language with untyped <code>Exp</code> data type, when consuming a represented program, we have to add type coercions to convince the type system : we check the value of type <code>Exp</code> received <em>really</em> contains the expected data inside, and we assert that to the compiler in some way to do something with it.</p>
<p>If we use GADT, some extra type information is packed with the data constructor/destructor. as we pattern math on the value, the type become more precise as the index gets fixed. we uncover type information as we uncover data information.</p>
<p>This makes evaluation straightforward :</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Term1</span> a <span class="kw">where</span>
  <span class="dt">Zero</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Int</span>
  <span class="dt">Succ</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term1</span> <span class="dt">Int</span>
  <span class="dt">Pred</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term1</span> <span class="dt">Int</span>
  <span class="dt">IsZero</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Int</span>  <span class="ot">-&gt;</span>  <span class="dt">Term1</span> <span class="dt">Bool</span>
  <span class="dt">If</span><span class="ot"> ::</span> <span class="dt">Term1</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Term1</span> a <span class="ot">-&gt;</span> <span class="dt">Term1</span> a <span class="ot">-&gt;</span> <span class="dt">Term1</span> a

<span class="ot">eval ::</span> forall a<span class="fu">.</span> <span class="dt">Term1</span> a <span class="ot">-&gt;</span> a
eval (<span class="dt">Zero</span> <span class="co">{- a is bound to Int from here-}</span>)  <span class="fu">=</span> <span class="dv">0</span> <span class="co">-- so 0 :: Int</span>
eval (<span class="dt">Succ</span> n<span class="co">{- a is bound to Int from here-}</span>) <span class="fu">=</span> eval n <span class="co">{-:: Int -}</span> <span class="fu">+</span> <span class="dv">1</span> <span class="co">-- type correct</span>
eval (<span class="dt">Pred</span> n)                                 <span class="fu">=</span> eval n <span class="fu">-</span> <span class="dv">1</span>
eval (<span class="dt">IsZero</span> n)                               <span class="fu">=</span> eval n <span class="fu">==</span> <span class="dv">0</span>
eval (<span class="dt">If</span> e1 e2 e3) <span class="fu">=</span> <span class="kw">if</span> eval e1 <span class="kw">then</span> eval e2 <span class="kw">else</span> eval e3</code></pre></div>
<p>There can not be a function <code>map :: (a -&gt; b) -&gt; Term1 a -&gt; Term1 b</code></p>
<p>The type index in term does not mean there is a value of that type in it to apply <code>a -&gt; b</code> to. It is called a ‚Äúphantom type‚Äù, other name for an type index seen as a ‚Äúpure index‚Äù <code>a</code> for the overall type <code>Term a</code>, not necessarily linked to a data. The type level has a life on its own. It more accurately reflect <em>static</em> information. the type of some variable, is, in a static language, part of the available information statically, but only a subset of it.</p>
<h1 id="generic-function">Generic Function</h1>
<h2 id="the-problem">The problem</h2>
<p>We want to compress data. We would like the same procedure to works for many types of data, provided its type can be described as a combination of basic types. This description could have been a type level description through with type classes, but here we have a value describing a type <code>a</code>. that value, named representation of a type will be of type <code>Type a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Type</span> a <span class="kw">where</span>
  <span class="dt">RInt</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="dt">Int</span>
  <span class="dt">RChar</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="dt">Char</span>
  <span class="dt">RList</span><span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> [a]
  <span class="dt">RPair</span><span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> b <span class="ot">-&gt;</span> <span class="dt">Type</span> (a, b)
  <span class="dt">RDyn</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="dt">Dynamic</span>
  <span class="dt">RFun</span><span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> <span class="dt">Type</span> b <span class="ot">-&gt;</span> <span class="dt">Type</span> (a <span class="ot">-&gt;</span> b)
  <span class="dt">RPerson</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="dt">Person</span>

<span class="ot">rString ::</span> <span class="dt">Type</span> <span class="dt">String</span>
rString <span class="fu">=</span> <span class="dt">RList</span> <span class="dt">RChar</span></code></pre></div>
<p>Our goal is to parameterize a function <code>compress</code> with the representation of the type of the value given. Different values yield different types for the resulting curried function</p>
<p>With all this we have access to the following magically safe operations :</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> _ <span class="fu">=</span> compress <span class="dt">RInt</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
<span class="ot">&gt;</span> _ <span class="fu">=</span> compress (<span class="dt">RPair</span> <span class="dt">RInt</span> <span class="dt">RChar</span>)<span class="ot"> ::</span> (<span class="dt">Int</span>, <span class="dt">Char</span>) <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]</code></pre></div>
<p>(Having the compiler to find a representation for any types is the subject of <a href="https://www.seas.upenn.edu/~sweirich/papers/wadlerfest2016.pdf">a reflection on types</a> see also <a href="https://www.cis.upenn.edu/~sweirich/talks/compose16.pdf">slides</a> in ghc 8.2)</p>
<p>This is achieved in a similar way that the <code>eval</code> function</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Bit</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">toBinary ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
toBinary <span class="dv">0</span> <span class="fu">=</span> []
toBinary x <span class="fu">=</span> (x <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="fu">:</span> (toBinary <span class="fu">$</span> x <span class="ot">`div`</span> <span class="dv">2</span>)

<span class="ot">toNumber&#39; ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
toNumber&#39; [] _       <span class="fu">=</span> <span class="dv">0</span>
toNumber&#39; (b <span class="fu">:</span> bs) t <span class="fu">=</span> b <span class="fu">*</span> t <span class="fu">+</span> toNumber&#39; bs (t <span class="fu">*</span> <span class="dv">2</span>)

<span class="ot">toNumber ::</span> [<span class="dt">Bit</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
toNumber <span class="fu">=</span> flip toNumber&#39; <span class="dv">1</span>

<span class="ot">padding ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
padding p x <span class="fu">=</span> <span class="kw">let</span> b <span class="fu">=</span> toBinary x
                  len <span class="fu">=</span> length b
              <span class="kw">in</span> <span class="kw">if</span> p <span class="fu">&lt;=</span> len <span class="kw">then</span> b
                 <span class="kw">else</span> b <span class="fu">++</span> take (p <span class="fu">-</span> len) (repeat <span class="dv">0</span>)

<span class="ot">compressInt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
compressInt <span class="fu">=</span> padding <span class="dv">32</span>

<span class="ot">compressChar ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
compressChar x <span class="fu">=</span> padding <span class="dv">7</span> <span class="fu">$</span> ord x

<span class="ot">compress ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Bit</span>]
compress <span class="dt">RInt</span> x               <span class="fu">=</span> compressInt x
compress <span class="dt">RChar</span> c              <span class="fu">=</span> compressChar c
compress (<span class="dt">RList</span> _) []         <span class="fu">=</span> <span class="dv">0</span><span class="fu">:</span>[]
compress (<span class="dt">RList</span> ra) (x <span class="fu">:</span> xs)  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> compress ra x <span class="fu">++</span> compress (<span class="dt">RList</span> ra) xs
compress (<span class="dt">RPair</span> ra rb) (x, y) <span class="fu">=</span> compress ra x <span class="fu">++</span> compress rb y
compress <span class="dt">RDyn</span> (<span class="dt">Dyn</span> ra x)      <span class="fu">=</span> compressRep (<span class="dt">Rep</span> ra) <span class="fu">++</span> compress ra x
</code></pre></div>
<p>The <em>correct</em> way to see <code>compress</code> is as a <em>family</em> of functions, indexed by a value representing a type. We could index directly with a type, and get rid of the representation. This then requires type classes. Type class allow to talk about, say, <em>compressable</em> types and require that as an implicit constraint. The compiler would do for you the job of selecting the correct function from this famility with no representation being passed around. Another difference is that this selection would wire the correct function at static time and not require an interpretation at run time resulting in faster code.</p>
<h2 id="equality-comparison-..">Equality, comparison, ..</h2>
<p>To see that this is a general concept, we can provide generically other operations which are naturally thought of as <em>generic</em> : if we can compare the parts, we should be able to compare structures made of the parts.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eq ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
eq <span class="dt">RInt</span> x y <span class="fu">=</span> x <span class="fu">==</span> y
eq <span class="dt">RChar</span> x y <span class="fu">=</span> x <span class="fu">==</span> y
eq (<span class="dt">RList</span> _) [] [] <span class="fu">=</span> <span class="dt">True</span>
eq (<span class="dt">RList</span> ra) (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">|</span> eq ra x y <span class="fu">=</span> eq (<span class="dt">RList</span> ra) xs ys
                                <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">False</span>
eq (<span class="dt">RList</span> _) _ _ <span class="fu">=</span> <span class="dt">False</span>
eq (<span class="dt">RPair</span> ra rb) (x, y) (x&#39;, y&#39;) <span class="fu">=</span> eq ra x x&#39; <span class="fu">&amp;&amp;</span> eq rb y y&#39;
eq <span class="dt">RDyn</span> (<span class="dt">Dyn</span> ra x) (<span class="dt">Dyn</span> rb y) <span class="fu">=</span> <span class="kw">case</span> teq ra rb <span class="kw">of</span>
                                 <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span>
                                 <span class="dt">Just</span> f  <span class="ot">-&gt;</span> eq rb (f x) y

compare<span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>
compare <span class="dt">RInt</span> x y <span class="fu">=</span> DO.compare x y
compare <span class="dt">RChar</span> x y <span class="fu">=</span> DO.compare x y
compare (<span class="dt">RList</span> _) [] [] <span class="fu">=</span> <span class="dt">EQ</span>
compare (<span class="dt">RList</span> _) [] (_ <span class="fu">:</span> _) <span class="fu">=</span> <span class="dt">LT</span>
compare (<span class="dt">RList</span> _) (_ <span class="fu">:</span> _) [] <span class="fu">=</span> <span class="dt">GT</span>
compare (<span class="dt">RList</span> ra) (x <span class="fu">:</span> xs) (y <span class="fu">:</span> ys) <span class="fu">=</span> <span class="kw">if</span> result <span class="fu">==</span> <span class="dt">EQ</span> <span class="kw">then</span> compare (<span class="dt">RList</span> ra) xs ys
                                       <span class="kw">else</span> result
  <span class="kw">where</span> result <span class="fu">=</span> compare ra x y
compare (<span class="dt">RPair</span> ra rb) (x, y) (x&#39;, y&#39;) <span class="fu">=</span> <span class="kw">if</span> first <span class="fu">==</span> <span class="dt">EQ</span> <span class="kw">then</span> compare rb y y&#39; <span class="kw">else</span> first
  <span class="kw">where</span> first <span class="fu">=</span> compare ra x x&#39;
compare <span class="dt">RDyn</span> (<span class="dt">Dyn</span> ra x) (<span class="dt">Dyn</span> rb y) <span class="fu">=</span> <span class="kw">case</span> teq ra rb <span class="kw">of</span>
                                      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;cannot compare&quot;</span>
                                      <span class="dt">Just</span> f  <span class="ot">-&gt;</span> compare rb (f x) y</code></pre></div>
<h1 id="boosting-compress">Boosting compress</h1>
<p>compress has type <code>Type a -&gt; TCompress a</code> where <code>TCompress a = a -&gt; [Bit]</code> This type function works Compare need a value (the representation)</p>
<h1 id="the-open-world">The open world</h1>
<p>TBC</p>

]]></summary>
</entry>
<entry>
    <title>Design - part 1 - controlling export with modules and types</title>
    <link href="http://xquant.net/notes/LibraryPhantom/readme.html" />
    <id>http://xquant.net/notes/LibraryPhantom/readme.html</id>
    <published>2017-04-09T00:00:00Z</published>
    <updated>2017-04-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on April  9, 2017
    
</div>
<div class="info">
    
</div>



<p>This is a series of design strategies from <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf">fun with phantom type</a>. This is only the first part, as the paper covers a few aspects.</p>
<h1 id="raw">Raw</h1>
<p>First do everything in a single file can be a good strategy for fast results. But abstracting away can also <em>drive</em> the design, which means it pays off for itself directly upfront.</p>
<h1 id="modules-and-abstraction">Modules and abstraction</h1>
<p>Separates the service provided from the implementation, in particular the data <em>representation</em>, chosen.</p>
<p>Representation choice adresses the <em>algorithmic</em> concerns. It influence the execution, not the service provided.</p>
<p>For instance this logger shields the internal representation from its user. It only exports the type constructor <code>Logger</code> - no data constructor - and the accompanying functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">#!/usr/bin/env stack</span>
<span class="co">-- stack script --resolver lts-8.8</span>


<span class="ot">{-# LANGUAGE GADTs #-}</span>
<span class="co">-- nous faisons une librarie et gardons opaques les types</span>
<span class="co">-- son implementation est asynchone mais son interface est synchrone</span>
<span class="co">-- on utilise dans un programme/thread normal et l&#39;utilisateur n&#39;a pas</span>
<span class="co">-- a se soucier de la maniere dont c&#39;est implemente</span>
<span class="co">-- dans son utilisation, il sera impacte par notre implementation</span>
<span class="co">-- Par exemple il pourra devoir attendre s&#39;il veut poster un message et que nous ne</span>
<span class="co">-- l&#39;avons pas encore traite.</span>


<span class="kw">module</span> <span class="dt">Logger</span> (<span class="dt">Logger</span>,
               initLogger,
               logMessage,
               logStop)
    <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Control.Concurrent</span>

<span class="co">-- en *interne*, un logger est une variable partagee</span>
<span class="co">-- dans laquelle on peut ecrire / lire des commandes</span>
<span class="kw">data</span> <span class="dt">Logger</span> <span class="kw">where</span>
  <span class="dt">Logger</span><span class="ot"> ::</span> <span class="dt">MVar</span> <span class="dt">LoggerCommand</span> <span class="ot">-&gt;</span> <span class="dt">Logger</span>

<span class="kw">data</span> <span class="dt">LoggerCommand</span> <span class="kw">where</span>
   <span class="dt">Message</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">LoggerCommand</span>
   <span class="dt">Stop</span><span class="ot"> ::</span> <span class="dt">MVar</span> () <span class="ot">-&gt;</span> <span class="dt">LoggerCommand</span>

<span class="ot">initLogger ::</span> <span class="dt">IO</span> <span class="dt">Logger</span>
initLogger <span class="fu">=</span> <span class="kw">do</span>
   v <span class="ot">&lt;-</span> newEmptyMVar  <span class="co">-- et implemente selon semantique interne</span>
   <span class="kw">let</span> l <span class="fu">=</span> <span class="dt">Logger</span> v
   forkIO <span class="fu">$</span> spin l   <span class="co">-- qui est un external thread</span>
   return l


<span class="co">-- fonction interne</span>
spin l<span class="fu">@</span>(<span class="dt">Logger</span> sv) <span class="fu">=</span> <span class="kw">do</span> putStrLn <span class="st">&quot;Started logger&quot;</span>
                        loop
  <span class="kw">where</span> loop <span class="fu">=</span> <span class="kw">do</span>
          cmd <span class="ot">&lt;-</span> takeMVar sv  <span class="co">-- on ecoute en bloquant</span>
          <span class="kw">case</span> cmd <span class="kw">of</span>
            <span class="dt">Message</span> msg <span class="ot">-&gt;</span> <span class="kw">do</span>
             putStrLn msg
             loop
            <span class="dt">Stop</span> stopv <span class="ot">-&gt;</span> <span class="kw">do</span>
             putStrLn <span class="st">&quot;Stopped logger&quot;</span>
             putMVar stopv ()
             return ()

<span class="ot">logMessage ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logMessage (<span class="dt">Logger</span> sv) msg <span class="fu">=</span> putMVar sv (<span class="dt">Message</span> msg)

<span class="ot">logStop ::</span> <span class="dt">Logger</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
logStop (<span class="dt">Logger</span> sv) <span class="fu">=</span> <span class="kw">do</span>
     stopv <span class="ot">&lt;-</span> newEmptyMVar
     putMVar sv (<span class="dt">Stop</span> stopv)
     _ <span class="ot">&lt;-</span> takeMVar stopv
     return ()


<span class="ot">test ::</span> <span class="dt">IO</span> ()
test <span class="fu">=</span> <span class="kw">do</span>
  l <span class="ot">&lt;-</span> initLogger
  logMessage l <span class="st">&quot;hello&quot;</span>
  logMessage l <span class="st">&quot;Goodbye&quot;</span>
  logStop l


<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> test</code></pre></div>
<h1 id="modules-pattern-in-haskell">Modules pattern in haskell</h1>
<p>One can add a file whose sole purpose is to perform abstraction : This file control what gets exported out, but has no code. Internal directory contains all the code and contian no export control, everything is public as far as it is concerned.</p>
<p>In <a href="https://github.com/turingjump/bookkeeper">bookeeper</a>, the file <a href="https://github.com/turingjump/bookkeeper/blob/master/src/Bookkeeper.hs">bookkeeper.hs</a> does exactly that.</p>
<p>More advanced strategies will be available with <a href="http://plv.mpi-sws.org/backpack/">backpack</a> soon</p>
<h1 id="phantom-type">Phantom type</h1>
<p>illustrating ideas from <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/With.pdf">fun with phantom type</a> the commented code is from <a href="https://gist.github.com/linusyang/4057470cf96b88d13bd8">here</a></p>
<p>The name ‚Äúphantom types‚Äù is motivated by the fact that no actual data is ever attached to those types. Types are usually seen as a property of some data.</p>
<p>But when looking at what we can do with types this is a wrong idea : Types stand for static knowledge of any kind.</p>
<p>Example from the <a href="https://wiki.haskell.org/Phantom_type">haskell wiki</a></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- you have no *data* constructor, you can not create value of that type</span>
<span class="co">-- but you can still *talk* about that type, whose values might be handed to you</span>
<span class="kw">module</span> <span class="dt">MyAPI</span>(<span class="dt">FormData</span>, <span class="co">--type constructor</span>
             formData, <span class="co">-- smart constructor WE decide at what index values are created</span>
             validate, <span class="co">-- normal API</span>
             useData,
             lifSmallChange,
            ) <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Protolude</span>

<span class="co">-- FormData is a type constructor of kind :: * -&gt; *</span>
<span class="co">-- Given any type a of kind *, FormData a is of kind *</span>
<span class="kw">data</span> <span class="dt">FormData</span> a  <span class="kw">where</span>
  <span class="co">-- invoking the data constructor FormData with some text</span>
  <span class="co">-- creates a value of type FormData a where the CALLER chooses what a</span>
   <span class="dt">FormData</span><span class="ot"> ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">FormData</span> a

<span class="co">-- withouth data constructor, impossible for clients to</span>
<span class="co">--  - inspect what&#39;s inside a value v :: FormaData Text</span>
<span class="co">--  - build a value v :: FormData i where THEY choose i</span>
<span class="ot">changeType ::</span> <span class="dt">FormData</span> a <span class="ot">-&gt;</span> <span class="dt">FormData</span> b
changeType (<span class="dt">FormData</span> str) <span class="fu">=</span> <span class="dt">FormData</span> str


<span class="kw">data</span> <span class="dt">Validated</span>
<span class="kw">data</span> <span class="dt">Unvalidated</span>

<span class="co">-- but WE can CHOOSE whichever type</span>
<span class="ot">formData ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">FormData</span> <span class="dt">Unvalidated</span> <span class="co">-- WE decide that if you call this, the data is Unvalidated</span>
formData str <span class="fu">=</span> <span class="dt">FormData</span> str

<span class="co">-- we decide you can only ask use to consume validated data</span>
<span class="ot">useData ::</span> <span class="dt">FormData</span> <span class="dt">Validated</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
useData (<span class="dt">FormData</span> str) <span class="fu">=</span> undefined <span class="co">-- logic here</span>

<span class="co">-- that means we FORCE YOU to call this function at *some* point before</span>
<span class="ot">validate ::</span> <span class="dt">FormData</span> <span class="dt">Unvalidated</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">FormData</span> <span class="dt">Validated</span>)
validate (<span class="dt">FormData</span> str) <span class="fu">=</span> undefined <span class="co">-- logic here</span>


<span class="co">-- benign operation</span>
<span class="ot">liftSmallChange ::</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>) <span class="ot">-&gt;</span> <span class="dt">FormData</span> a <span class="ot">-&gt;</span> <span class="dt">FormData</span> a
liftSmallChange <span class="fu">=</span> undefined <span class="co">-- logic which only touch small stuff</span>


<span class="co">-- big operation - you have to revalidate !</span>
<span class="ot">liftBigChange ::</span> (<span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span>) <span class="ot">-&gt;</span> <span class="dt">FormData</span> a <span class="ot">-&gt;</span> <span class="dt">FormData</span> <span class="dt">Unvalidated</span>
liftBigChange <span class="fu">=</span> undefined <span class="co">-- logic which can touch anything</span></code></pre></div>
<p>with this, we separate validation from action, and prevent you from tampering after it‚Äôs validated, while still allowing you maximum freedom in how you operate. we keep control, you keep freedom</p>
<h1 id="middleware-pattern">Middleware pattern</h1>
<p>one direct example of this is the middleware pattern</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Middleware</span>(<span class="dt">EndForYou</span>, <span class="co">-- type constructor</span>
                  serve      <span class="co">-- run your application</span>
            ) <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Protolude</span>

<span class="kw">data</span> <span class="dt">EndForYou</span> <span class="kw">where</span>
   <span class="dt">TheEndCtor</span><span class="ot"> ::</span> <span class="dt">EndForYou</span>


app0 <span class="fu">=</span><span class="ot"> undefined ::</span> response
app1 <span class="fu">=</span><span class="ot"> undefined ::</span> (response <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>) <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>
app2 <span class="fu">=</span><span class="ot"> undefined ::</span> input <span class="ot">-&gt;</span> (response <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>) <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>


<span class="kw">type</span> <span class="dt">Application</span> input response m <span class="fu">=</span> input <span class="ot">-&gt;</span> (response <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>) <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>

<span class="ot">serve ::</span> <span class="dt">Application</span> input output m <span class="ot">-&gt;</span> input <span class="ot">-&gt;</span> m <span class="dt">EndForYou</span>
serve yourServer input <span class="fu">=</span> (yourServer input) process
  <span class="kw">where</span> process response <span class="fu">=</span> undefined <span class="co">-- actually sends the response</span>


<span class="co">-- cote client il y aura</span>
<span class="ot">receive ::</span> response <span class="ot">-&gt;</span> next
receive <span class="fu">=</span> undefined
</code></pre></div>
<h1 id="types-at-work">Types at Work</h1>
<p>Types are nice, but in haskell they are not just decoration and checking. They are PART of the code, they DECIDE what to do. ‚ÄúType is data‚Äù</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Sanitise</span> a <span class="kw">where</span>
<span class="ot">  sanitise ::</span> <span class="dt">FormData</span> a <span class="ot">-&gt;</span> <span class="dt">FormData</span> <span class="dt">Validated</span>

<span class="co">-- do nothing to data that is already validated</span>
<span class="kw">instance</span> <span class="dt">Sanitise</span> <span class="dt">Validated</span> <span class="kw">where</span>
  sanitise <span class="fu">=</span> identity

<span class="co">-- sanitise untrusted data</span>
<span class="kw">instance</span> <span class="dt">Sanitise</span> <span class="dt">Unvalidated</span> <span class="kw">where</span>
  sanitise (<span class="dt">FormData</span> str) <span class="fu">=</span> <span class="dt">FormData</span> (filter isAlpha str) <span class="kw">where</span> filter <span class="fu">=</span> undefined
                                                                isAlpha <span class="fu">=</span> undefined


a <span class="fu">=</span> <span class="dt">FormData</span> <span class="st">&quot;Hello&quot;</span>

<span class="co">-- the type chooses what will be done !</span>
_ <span class="fu">=</span> sanitise (<span class="ot">a ::</span> <span class="dt">FormData</span> <span class="dt">Unvalidated</span>)
_ <span class="fu">=</span> sanitise (<span class="ot">a ::</span> <span class="dt">FormData</span> <span class="dt">Validated</span>)

<span class="co">-- if it can&#39;t, it&#39;s an error, just like a syntax error</span>
_ <span class="fu">=</span> sanitise a <span class="co">-- error !</span></code></pre></div>

]]></summary>
</entry>
<entry>
    <title>Test post, let's draw stuff</title>
    <link href="http://xquant.net/notes/cats1and2/readme.html" />
    <id>http://xquant.net/notes/cats1and2/readme.html</id>
    <published>2017-03-27T00:00:00Z</published>
    <updated>2017-03-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on March 27, 2017
    
</div>
<div class="info">
    
</div>



<p>Just a test post to see if things work</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; example1 ::</span> <span class="dt">Diagram</span> <span class="dt">B</span>
<span class="ot">&gt;</span> example1 <span class="fu">=</span> square <span class="dv">1</span> <span class="fu">#</span> fc red
<span class="ot">&gt;</span>                    <span class="fu">#</span> lw veryThick
<span class="ot">&gt;</span>                    <span class="fu">#</span> lc black
<span class="ot">&gt;</span>                    <span class="fu">#</span> dashingG [<span class="fl">0.2</span>,<span class="fl">0.05</span>] <span class="dv">0</span></code></pre></div>
<p>Diagram from above : <img src="static/example1.svg" /></p>
<p>Or from some library :</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> out11 <span class="fu">=</span><span class="ot"> example11 ::</span> <span class="dt">Diagram</span> <span class="dt">B</span></code></pre></div>
<div class="figure">
<img src="static/out11.svg" />

</div>
<p>which means we can go deep with some project, using standard tools, and then provide a good summary of the artefact it can produce</p>

]]></summary>
</entry>
<entry>
    <title>Directed Acyclic Graphs</title>
    <link href="http://xquant.net/notes/graphvalue/readme.html" />
    <id>http://xquant.net/notes/graphvalue/readme.html</id>
    <published>2017-02-03T00:00:00Z</published>
    <updated>2017-02-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on February  3, 2017
    
</div>
<div class="info">
    
</div>



<h5 id="section"></h5>
<hr />
<h2 id="representing-graphs">Representing graphs</h2>
<p>There are a few ways to represent a graph:</p>
<ul>
<li>as a list of Nodes and a list of edges</li>
<li>as a list of neighbors</li>
</ul>
<p>each representation is optimized for a runtime behaviour (cf Kormen) but it‚Äôs useful to abstract representation to express operations. A convenient way to abstract over those representations is shown in <a href="https://scholar.google.fr/scholar?cluster=6598618604128829558&amp;hl=en&amp;as_sdt=0,5&amp;sciodt=0,5">Fun with type function</a></p>
<p>But what if we could abuse haskell somehow to represent graph not with some external description but with haskell itself ?</p>
<hr />
<h2 id="breaking-referential-transparency">Breaking referential transparency</h2>
<p>We want to write graph that way</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; graph1 ::</span> <span class="dt">Tree</span> <span class="dt">IntTreeF</span>
<span class="ot">&gt;</span> graph1 <span class="fu">=</span> iNode (iNode (iLeaf <span class="dv">2</span>) a) b
<span class="ot">&gt;</span>            <span class="kw">where</span> a <span class="fu">=</span> iNode (iNode (iLeaf <span class="dv">2</span>)(iLeaf <span class="dv">2</span>)) (iLeaf <span class="dv">2</span>)
<span class="ot">&gt;</span>                  b <span class="fu">=</span> a</code></pre></div>
<p>instead of some variation of</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- graph1&#39; = mkDag (Node (Node (Leaf 2) (Ref 0)) (Ref 0)) [(0, Node (Node (Leaf 2) (Leaf 2)) (Leaf 2))]</span></code></pre></div>
<p>But normally, in Haskell there should be no way to distinguish graph1 from</p>
<p>from</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; graph2 ::</span> <span class="dt">Tree</span> <span class="dt">IntTreeF</span>
<span class="ot">&gt;</span> graph2 <span class="fu">=</span>  iNode (iNode (iLeaf <span class="dv">2</span>) a) b
<span class="ot">&gt;</span>            <span class="kw">where</span> a <span class="fu">=</span> iNode (iNode (iLeaf <span class="dv">2</span>) (iLeaf <span class="dv">2</span>)) (iLeaf <span class="dv">2</span>)
<span class="ot">&gt;</span>                  b <span class="fu">=</span> iNode (iNode (iLeaf <span class="dv">2</span>) (iLeaf <span class="dv">2</span>)) (iLeaf <span class="dv">2</span>)</code></pre></div>
<p>But we can actually abuse haskell by going to <code>IO</code> and relying on some implementation of GHC to observe the sharing using <a href="https://scholar.google.fr/scholar?cluster=13707349448701947240&amp;hl=en&amp;as_sdt=0,5&amp;sciodt=0,5">Type-safe observable sharing in Haskell</a> a technique implemented and extended in <a href="http://hackage.haskell.org/package/data-reify">data-reify</a></p>
<p>With this we can produce two different output for two values which <em>should have been</em> be undistinguishable.</p>
<table>
<thead>
<tr class="header">
<th align="center">graph1</th>
<th align="center">graph2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center"><img src="static/graph1.svg" /></td>
<td align="center"><img src="static/graph2.svg" /></td>
</tr>
</tbody>
</table>
<p>basically the second graph is maximal sharing of subnodes. because we only ever use names like a and b once, they are irrelevant. whereas in the first case, this bottom leaf 2 is not really <em>any</em> leaf 2, it is the leaf which comes from <code>a</code> which should also be equal to <code>b</code> as a graph. to make sure they are equal, the equivalent relation a = b gets its own private copy which is not shared with other subgraphs.</p>
<p>using this we can directly represent graphs with haskell which is convienent and more visual than labeling nodes. indeed compare the code, visual, with the following ‚Äònormal‚Äô representation of first and second example.</p>
<p>T</p>
<ul>
<li>traversals (control - cps, mendler, launchbury coroutining fold)</li>
<li>names (polymorphism)</li>
<li>regions (applicative batching, compdata)</li>
</ul>

]]></summary>
</entry>

</feed>
